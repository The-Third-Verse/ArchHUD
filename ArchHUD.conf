name: ArchHud - Archaegeo v0.105 (Minified)
slots:
  core:
    class: CoreUnit
  radar:
    class: RadarPVPUnit
    select: manual
  antigrav:
    class: AntiGravityGeneratorUnit
  warpdrive:
    class: WarpDriveUnit
  gyro:
    class: GyroUnit
  weapon:
    class: WeaponUnit
    select: manual
  dbHud:
    class: databank
    select: manual
  telemeter:
    class: TelemeterUnit
    select: manual
  vBooster:
    class: VerticalBooster
  hover:
    class: Hovercraft
  door:
    class: DoorUnit
    select: manual
  switch:
    class: ManualSwitchUnit
    select: manual
  forcefield:
    class: ForceFieldUnit
    select: manual
  atmofueltank:
    class: AtmoFuelContainer
    select: manual
  spacefueltank:
    class: SpaceFuelContainer
    select: manual
  rocketfueltank:
    class: RocketFuelContainer
    select: manual
  shield:
    class: ShieldGeneratorUnit
  screenHud:
    class: ScreenUnit
    select: manual
  transponder:
    class: TransponderUnit
    select: manual
handlers:
  unit:
    onStart:
      lua: |
        __wrap_lua__stopped=false
        __wrap_lua__stopOnError=false
        __wrap_lua__rethrowErrorAlways=false
        __wrap_lua__rethrowErrorIfStopped=true
        __wrap_lua__printError=true
        function __wrap_lua__error(a) if __wrap_lua__stopped then return end a=tostring(a):gsub('"%-%- |STDERROR%-EVENTHANDLER[^"]*"','chunk'):gsub("&","&amp;"):gsub("<","&lt;"):gsub(">","&gt;") local b=unit or self or {} if __wrap_lua__printError and system and system.print then system.print("Error: "..a:gsub("\n","<br>")) end if __wrap_lua__stopOnError then __wrap_lua__stopped=true end if __wrap_lua__stopped and b and b.exit then b.exit() end if __wrap_lua__rethrowErrorAlways or (__wrap_lua__stopped and __wrap_lua__rethrowErrorIfStopped) then error(a) end end __wrap_lua__traceback=traceback or (debug and debug.traceback) or function(a,b)return b or a end local a,b=xpcall(function() local a=system;local b=core;local c=unit;local d=Navigator.new(a,b,c)script={}VERSION_NUMBER=0.105;useTheseSettings=false;userControlScheme="keyboard"soundFolder="archHUD"privateFile="name"customAtlas="atlas"freeLookToggle=true;BrakeToggleDefault=true;RemoteFreeze=false;RemoteHud=false;brightHud=false;VanillaRockets=false;InvertMouse=false;autoRollPreference=false;ExternalAGG=false;ShouldCheckDamage=false;AtmoSpeedAssist=true;ForceAlignment=false;DisplayDeadZone=true;showHud=true;hideHudOnToggleWidgets=true;ShiftShowsRemoteButtons=true;SetWaypointOnExit=false;AlwaysVSpd=false;BarFuelDisplay=true;voices=true;alerts=true;CollisionSystem=true;AbandonedRadar=false;AutoShieldToggle=true;PreventPvP=true;DisplayOdometer=true;ECUHud=false;MaintainOrbit=true;saveableVariablesBoolean={userControlScheme={set=function(i)userControlScheme=i end,get=function()return userControlScheme end},soundFolder={set=function(i)soundFolder=i end,get=function()return soundFolder end},privateFile={set=function(i)privateFile=i end,get=function()return privateFile end},customAtlas={set=function(i)customAtlas=i end,get=function()return privateFile end},freeLookToggle={set=function(i)freeLookToggle=i end,get=function()return freeLookToggle end},BrakeToggleDefault={set=function(i)BrakeToggleDefault=i end,get=function()return BrakeToggleDefault end},RemoteFreeze={set=function(i)RemoteFreeze=i end,get=function()return RemoteFreeze end},brightHud={set=function(i)brightHud=i end,get=function()return brightHud end},RemoteHud={set=function(i)RemoteHud=i end,get=function()return RemoteHud end},VanillaRockets={set=function(i)VanillaRockets=i end,get=function()return VanillaRockets end},InvertMouse={set=function(i)InvertMouse=i end,get=function()return InvertMouse end},autoRollPreference={set=function(i)autoRollPreference=i end,get=function()return autoRollPreference end},ExternalAGG={set=function(i)ExternalAGG=i end,get=function()return ExternalAGG end},ShouldCheckDamage={set=function(i)ShouldCheckDamage=i end,get=function()return ShouldCheckDamage end},AtmoSpeedAssist={set=function(i)AtmoSpeedAssist=i end,get=function()return AtmoSpeedAssist end},ForceAlignment={set=function(i)ForceAlignment=i end,get=function()return ForceAlignment end},DisplayDeadZone={set=function(i)DisplayDeadZone=i end,get=function()return DisplayDeadZone end},showHud={set=function(i)showHud=i end,get=function()return showHud end},hideHudOnToggleWidgets={set=function(i)hideHudOnToggleWidgets=i end,get=function()return hideHudOnToggleWidgets end},ShiftShowsRemoteButtons={set=function(i)ShiftShowsRemoteButtons=i end,get=function()return ShiftShowsRemoteButtons end},SetWaypointOnExit={set=function(i)SetWaypointOnExit=i end,get=function()return SetWaypointOnExit end},AlwaysVSpd={set=function(i)AlwaysVSpd=i end,get=function()return AlwaysVSpd end},BarFuelDisplay={set=function(i)BarFuelDisplay=i end,get=function()return BarFuelDisplay end},voices={set=function(i)voices=i end,get=function()return voices end},alerts={set=function(i)alerts=i end,get=function()return alerts end},CollisionSystem={set=function(i)CollisionSystem=i end,get=function()return CollisionSystem end},AbandonedRadar={set=function(i)AbandonedRadar=i end,get=function()return AbandonedRadar end},AutoShieldToggle={set=function(i)AutoShieldToggle=i end,get=function()return AutoShieldToggle end},PreventPvP={set=function(i)PreventPvP=i end,get=function()return PreventPvP end},DisplayOdometer={set=function(i)DisplayOdometer=i end,get=function()return DisplayOdometer end},ECUHud={set=function(i)ECUHud=i end,get=function()return ECUHud end},MaintainOrbit={set=function(i)MaintainOrbit=i end,get=function()return MaintainOrbit end}}YawStallAngle=35;PitchStallAngle=35;brakeLandingRate=30;MaxPitch=30;ReEntryPitch=-30;AutopilotSpaceDistance=5000;TargetOrbitRadius=1.3;LowOrbitHeight=2000;AtmoSpeedLimit=1175;SpaceSpeedLimit=66000;AutoTakeoffAltitude=1000;TargetHoverHeight=50;LandingGearGroundHeight=0;ReEntryHeight=100000;MaxGameVelocity=-1.00;AutopilotInterplanetaryThrottle=1;warmup=32;fuelTankHandlingAtmo=0;fuelTankHandlingSpace=0;fuelTankHandlingRocket=0;ContainerOptimization=0;FuelTankOptimization=0;AutoShieldPercent=0;EmergencyWarp=0;DockingMode=1;savableVariablesHandling={YawStallAngle={set=function(i)YawStallAngle=i end,get=function()return YawStallAngle end},PitchStallAngle={set=function(i)PitchStallAngle=i end,get=function()return PitchStallAngle end},brakeLandingRate={set=function(i)brakeLandingRate=i end,get=function()return brakeLandingRate end},MaxPitch={set=function(i)MaxPitch=i end,get=function()return MaxPitch end},ReEntryPitch={set=function(i)ReEntryPitch=i end,get=function()return ReEntryPitch end},AutopilotSpaceDistance={set=function(i)AutopilotSpaceDistance=i end,get=function()return AutopilotSpaceDistance end},TargetOrbitRadius={set=function(i)TargetOrbitRadius=i end,get=function()return TargetOrbitRadius end},LowOrbitHeight={set=function(i)LowOrbitHeight=i end,get=function()return LowOrbitHeight end},AtmoSpeedLimit={set=function(i)AtmoSpeedLimit=i end,get=function()return AtmoSpeedLimit end},SpaceSpeedLimit={set=function(i)SpaceSpeedLimit=i end,get=function()return SpaceSpeedLimit end},AutoTakeoffAltitude={set=function(i)AutoTakeoffAltitude=i end,get=function()return AutoTakeoffAltitude end},TargetHoverHeight={set=function(i)TargetHoverHeight=i end,get=function()return TargetHoverHeight end},LandingGearGroundHeight={set=function(i)LandingGearGroundHeight=i end,get=function()return LandingGearGroundHeight end},ReEntryHeight={set=function(i)ReEntryHeight=i end,get=function()return ReEntryHeight end},MaxGameVelocity={set=function(i)MaxGameVelocity=i end,get=function()return MaxGameVelocity end},AutopilotInterplanetaryThrottle={set=function(i)AutopilotInterplanetaryThrottle=i end,get=function()return AutopilotInterplanetaryThrottle end},warmup={set=function(i)warmup=i end,get=function()return warmup end},fuelTankHandlingAtmo={set=function(i)fuelTankHandlingAtmo=i end,get=function()return fuelTankHandlingAtmo end},fuelTankHandlingSpace={set=function(i)fuelTankHandlingSpace=i end,get=function()return fuelTankHandlingSpace end},fuelTankHandlingRocket={set=function(i)fuelTankHandlingRocket=i end,get=function()return fuelTankHandlingRocket end},ContainerOptimization={set=function(i)ContainerOptimization=i end,get=function()return ContainerOptimization end},FuelTankOptimization={set=function(i)FuelTankOptimization=i end,get=function()return FuelTankOptimization end},AutoShieldPercent={set=function(i)AutoShieldPercent=i end,get=function()return AutoShieldPercent end},EmergencyWarp={set=function(i)EmergencyWarp=i end,get=function()return EmergencyWarp end},DockingMode={set=function(i)DockingMode=i end,get=function()return DockingMode end}}ResolutionX=1920;ResolutionY=1080;circleRad=400;SafeR=130;SafeG=224;SafeB=255;PvPR=255;PvPG=0;PvPB=0;centerX=960;centerY=540;throtPosX=1300;throtPosY=540;vSpdMeterX=1525;vSpdMeterY=325;altMeterX=550;altMeterY=540;fuelX=30;fuelY=700;shieldX=1750;shieldY=250;radarX=1750;radarY=350;DeadZone=50;OrbitMapSize=250;OrbitMapX=0;OrbitMapY=30;savableVariablesHud={ResolutionX={set=function(i)ResolutionX=i end,get=function()return ResolutionX end},ResolutionY={set=function(i)ResolutionY=i end,get=function()return ResolutionY end},circleRad={set=function(i)circleRad=i end,get=function()return circleRad end},SafeR={set=function(i)SafeR=i end,get=function()return SafeR end},SafeG={set=function(i)SafeG=i end,get=function()return SafeG end},SafeB={set=function(i)SafeB=i end,get=function()return SafeB end},PvPR={set=function(i)PvPR=i end,get=function()return PvPR end},PvPG={set=function(i)PvPG=i end,get=function()return PvPG end},PvPB={set=function(i)PvPB=i end,get=function()return PvPB end},centerX={set=function(i)centerX=i end,get=function()return centerX end},centerY={set=function(i)centerY=i end,get=function()return centerY end},throtPosX={set=function(i)throtPosX=i end,get=function()return throtPosX end},throtPosY={set=function(i)throtPosY=i end,get=function()return throtPosY end},vSpdMeterX={set=function(i)vSpdMeterX=i end,get=function()return vSpdMeterX end},vSpdMeterY={set=function(i)vSpdMeterY=i end,get=function()return vSpdMeterY end},altMeterX={set=function(i)altMeterX=i end,get=function()return altMeterX end},altMeterY={set=function(i)altMeterY=i end,get=function()return altMeterY end},fuelX={set=function(i)fuelX=i end,get=function()return fuelX end},fuelY={set=function(i)fuelY=i end,get=function()return fuelY end},shieldX={set=function(i)shieldX=i end,get=function()return shieldX end},shieldY={set=function(i)shieldY=i end,get=function()return shieldY end},radarX={set=function(i)radarX=i end,get=function()return radarX end},radarY={set=function(i)radarY=i end,get=function()return radarY end},DeadZone={set=function(i)DeadZone=i end,get=function()return DeadZone end},OrbitMapSize={set=function(i)OrbitMapSize=i end,get=function()return OrbitMapSize end},OrbitMapX={set=function(i)OrbitMapX=i end,get=function()return OrbitMapX end},OrbitMapY={set=function(i)OrbitMapY=i end,get=function()return OrbitMapY end}}speedChangeLarge=5.0;speedChangeSmall=1.0;MouseXSensitivity=0.003;MouseYSensitivity=0.003;autoRollFactor=2;rollSpeedFactor=1.5;autoRollRollThreshold=180;minRollVelocity=150;TrajectoryAlignmentStrength=0.002;torqueFactor=2;pitchSpeedFactor=0.8;yawSpeedFactor=1;brakeSpeedFactor=3;brakeFlatFactor=1;DampingMultiplier=40;hudTickRate=0.0666667;ExtraEscapeThrust=1.0;ExtraLongitudeTags="none"ExtraLateralTags="none"ExtraVerticalTags="none"allowedHorizontalDrift=0.05;FastOrbit=0.0;savableVariablesPhysics={speedChangeLarge={set=function(i)speedChangeLarge=i end,get=function()return speedChangeLarge end},speedChangeSmall={set=function(i)speedChangeSmall=i end,get=function()return speedChangeSmall end},MouseXSensitivity={set=function(i)MouseXSensitivity=i end,get=function()return MouseXSensitivity end},MouseYSensitivity={set=function(i)MouseYSensitivity=i end,get=function()return MouseYSensitivity end},autoRollFactor={set=function(i)autoRollFactor=i end,get=function()return autoRollFactor end},rollSpeedFactor={set=function(i)rollSpeedFactor=i end,get=function()return rollSpeedFactor end},autoRollRollThreshold={set=function(i)autoRollRollThreshold=i end,get=function()return autoRollRollThreshold end},minRollVelocity={set=function(i)minRollVelocity=i end,get=function()return minRollVelocity end},TrajectoryAlignmentStrength={set=function(i)TrajectoryAlignmentStrength=i end,get=function()return TrajectoryAlignmentStrength end},torqueFactor={set=function(i)torqueFactor=i end,get=function()return torqueFactor end},pitchSpeedFactor={set=function(i)pitchSpeedFactor=i end,get=function()return pitchSpeedFactor end},yawSpeedFactor={set=function(i)yawSpeedFactor=i end,get=function()return yawSpeedFactor end},brakeSpeedFactor={set=function(i)brakeSpeedFactor=i end,get=function()return brakeSpeedFactor end},brakeFlatFactor={set=function(i)brakeFlatFactor=i end,get=function()return brakeFlatFactor end},DampingMultiplier={set=function(i)DampingMultiplier=i end,get=function()return DampingMultiplier end},hudTickRate={set=function(i)hudTickRate=i end,get=function()return hudTickRate end},ExtraEscapeThrust={set=function(i)ExtraEscapeThrust=i end,get=function()return ExtraEscapeThrust end},ExtraLongitudeTags={set=function(i)ExtraLongitudeTags=i end,get=function()return ExtraLongitudeTags end},ExtraLateralTags={set=function(i)ExtraLateralTags=i end,get=function()return ExtraLateralTags end},ExtraVerticalTags={set=function(i)ExtraVerticalTags=i end,get=function()return ExtraVerticalTags end},allowedHorizontalDrift={set=function(i)allowedHorizontalDrift=i end,get=function()return allowedHorizontalDrift end},FastOrbit={set=function(i)FastOrbit=i end,get=function()return FastOrbit end}}BrakeToggleStatus=BrakeToggleDefault;VertTakeOffEngine=false;BrakeIsOn=false;RetrogradeIsOn=false;ProgradeIsOn=false;Autopilot=false;TurnBurn=false;AltitudeHold=false;BrakeLanding=false;AutoTakeoff=false;Reentry=false;VertTakeOff=false;HoldAltitude=1000;AutopilotAccelerating=false;AutopilotRealigned=false;AutopilotBraking=false;AutopilotCruising=false;AutopilotEndSpeed=0;AutopilotStatus="Aligning"PrevViewLock=true;AutopilotTargetName="None"AutopilotTargetCoords=nil;AutopilotTargetIndex=0;GearExtended=nil;TotalDistanceTravelled=0.0;TotalFlightTime=0;SavedLocations={}VectorToTarget=false;LocationIndex=0;LastMaxBrake=0;LockPitch=nil;LastMaxBrakeInAtmo=0;AntigravTargetAltitude=1000;LastStartTime=0;SpaceTarget=false;LeftAmount=0;IntoOrbit=false;iphCondition="All"stablized=true;UseExtra="Off"LastVersionUpdate=0.000;saveRoute={}apRoute={}ecuThrottle={}adjMaxGameVelocity=9000;autoVariables={VertTakeOff={set=function(i)VertTakeOff=i end,get=function()return VertTakeOff end},VertTakeOffEngine={set=function(i)VertTakeOffEngine=i end,get=function()return VertTakeOffEngine end},SpaceTarget={set=function(i)SpaceTarget=i end,get=function()return SpaceTarget end},BrakeToggleStatus={set=function(i)BrakeToggleStatus=i end,get=function()return BrakeToggleStatus end},BrakeIsOn={set=function(i)BrakeIsOn=i end,get=function()return BrakeIsOn end},RetrogradeIsOn={set=function(i)RetrogradeIsOn=i end,get=function()return RetrogradeIsOn end},ProgradeIsOn={set=function(i)ProgradeIsOn=i end,get=function()return ProgradeIsOn end},Autopilot={set=function(i)Autopilot=i end,get=function()return Autopilot end},TurnBurn={set=function(i)TurnBurn=i end,get=function()return TurnBurn end},AltitudeHold={set=function(i)AltitudeHold=i end,get=function()return AltitudeHold end},BrakeLanding={set=function(i)BrakeLanding=i end,get=function()return BrakeLanding end},Reentry={set=function(i)Reentry=i end,get=function()return Reentry end},AutoTakeoff={set=function(i)AutoTakeoff=i end,get=function()return AutoTakeoff end},HoldAltitude={set=function(i)HoldAltitude=i end,get=function()return HoldAltitude end},AutopilotAccelerating={set=function(i)AutopilotAccelerating=i end,get=function()return AutopilotAccelerating end},AutopilotBraking={set=function(i)AutopilotBraking=i end,get=function()return AutopilotBraking end},AutopilotCruising={set=function(i)AutopilotCruising=i end,get=function()return AutopilotCruising end},AutopilotRealigned={set=function(i)AutopilotRealigned=i end,get=function()return AutopilotRealigned end},AutopilotEndSpeed={set=function(i)AutopilotEndSpeed=i end,get=function()return AutopilotEndSpeed end},AutopilotStatus={set=function(i)AutopilotStatus=i end,get=function()return AutopilotStatus end},PrevViewLock={set=function(i)PrevViewLock=i end,get=function()return PrevViewLock end},AutopilotTargetName={set=function(i)AutopilotTargetName=i end,get=function()return AutopilotTargetName end},AutopilotTargetCoords={set=function(i)AutopilotTargetCoords=i end,get=function()return AutopilotTargetCoords end},AutopilotTargetIndex={set=function(i)AutopilotTargetIndex=i end,get=function()return AutopilotTargetIndex end},TotalDistanceTravelled={set=function(i)TotalDistanceTravelled=i end,get=function()return TotalDistanceTravelled end},TotalFlightTime={set=function(i)TotalFlightTime=i end,get=function()return TotalFlightTime end},SavedLocations={set=function(i)SavedLocations=i end,get=function()return SavedLocations end},VectorToTarget={set=function(i)VectorToTarget=i end,get=function()return VectorToTarget end},LocationIndex={set=function(i)LocationIndex=i end,get=function()return LocationIndex end},LastMaxBrake={set=function(i)LastMaxBrake=i end,get=function()return LastMaxBrake end},LockPitch={set=function(i)LockPitch=i end,get=function()return LockPitch end},LastMaxBrakeInAtmo={set=function(i)LastMaxBrakeInAtmo=i end,get=function()return LastMaxBrakeInAtmo end},AntigravTargetAltitude={set=function(i)AntigravTargetAltitude=i end,get=function()return AntigravTargetAltitude end},LastStartTime={set=function(i)LastStartTime=i end,get=function()return LastStartTime end},iphCondition={set=function(i)iphCondition=i end,get=function()return iphCondition end},stablized={set=function(i)stablized=i end,get=function()return stablized end},UseExtra={set=function(i)UseExtra=i end,get=function()return UseExtra end},SelectedTab={set=function(i)SelectedTab=i end,get=function()return SelectedTab end},saveRoute={set=function(i)saveRoute=i end,get=function()return saveRoute end},apRoute={set=function(i)apRoute=i end,get=function()return apRoute end},ecuThrottle={set=function(i)ecuThrottle=i end,get=function()return ecuThrottle end},adjMaxGameVelocity={set=function(i)adjMaxGameVelocity=i end,get=function()return adjMaxGameVelocity end}}local function e(b,c,f,g,h)local a=DUSystem;local j=DUConstruct;time=f()PlayerThrottle=0;brakeInput2=0;ThrottleLimited=false;calculatedThrottle=0;WasInCruise=false;hasGear=false;pitchInput=0;rollInput=0;yawInput=0;upAmount=0;followMode=false;holdingShift=false;leftmouseclick=false;msgText="empty"msgTimer=3;isBoosting=false;brakeDistance=0;brakeTime=0;autopilotTargetPlanet=nil;simulatedX=0;simulatedY=0;distance=0;spaceLand=false;spaceLaunch=false;finalLand=false;abvGndDet=-1;inAtmo=h()>0;atmosDensity=h()coreAltitude=b.getAltitude()coreMass=DUConstruct.getMass()gyroIsOn=nil;atmoTanks={}spaceTanks={}rocketTanks={}galaxyReference=nil;Kinematic=nil;Kep=nil;HUD=nil;ATLAS=nil;AP=nil;RADAR=nil;CONTROL=nil;SHIELD=nil;Animating=false;Animated=false;autoRoll=autoRollPreference;stalling=false;adjustedAtmoSpeedLimit=AtmoSpeedLimit;orbitMsg=nil;OrbitTargetOrbit=0;OrbitAchieved=false;SpaceEngineVertDn=false;SpaceEngines=false;constructForward=vec3(j.getWorldOrientationForward())constructRight=vec3(j.getWorldOrientationRight())coreVelocity=vec3(j.getVelocity())constructVelocity=vec3(j.getWorldVelocity())velMag=vec3(constructVelocity):len()worldVertical=vec3(b.getWorldVertical())vSpd=-worldVertical:dot(constructVelocity)worldPos=vec3(j.getWorldPosition())UpVertAtmoEngine=false;antigravOn=false;throttleMode=true;adjustedPitch=0;adjustedRoll=0;AtlasOrdered={}notPvPZone=false;pvpDist=50000;ReversalIsOn=nil;nearPlanet=c.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;collisionAlertStatus=false;collisionTarget=nil;apButtonsHovered=false;apScrollIndex=0;passengers={}ships={}planetAtlas={}scopeFOV=90;oldShowHud=showHud;ThrottleValue=nil;radarPanelID=nil;privatelocations={}customlocations={}apBrk=false;alignHeading=nil;mouseDistance=0;sEFC=false;MaxSpeed=j.getMaxSpeed()pipeDestC=nil;pipeDistC=nil;pipePosC=nil;pipePosT=nil;pipeDestT=nil;pipeDistT=nil;alignTarget=false;if shield then shieldPercent=g(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())end end;function p(k)a.print(time..": "..k)end;local a,l=pcall(require,"autoconf/custom/"..customAtlas)if not a then l=require("atlas")end;local function m(d,b,c,a,n,o,q,r,s)local function t(u)return type(u)=='number'end;local function v(u)return type(q(u))=='number'end;local function w(x)return type(x)=='table'end;local function y(a)return type(a)=='string'end;local function z(A)return w(A)and t(A.x and A.y and A.z)end;local function B(C)return w(C)and t(C.latitude and C.longitude and C.altitude and C.id and C.systemId)end;local D=math.pi/180;local E=180/math.pi;local epsilon=1e-10;local F=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local G='::pos{'..F..','..F..','..F..','..F..','..F..'}'local utils=utils;local vec3=vec3;local function H(u)local I=string.gsub(string.reverse(n('%.4f',u)),'^0*%.?','')return I==''and'0'or string.reverse(I)end;local function J(K)if z(K)then return n('{x=%.3f,y=%.3f,z=%.3f}',K.x,K.y,K.z)end;if w(K)and not getmetatable(K)then local L={}local M=next(K)if type(M)=='nil'or M==1 then L=K else for N,A in pairs(K)do local O=J(A)if type(N)=='number'then table.insert(L,n('[%s]=%s',N,O))else table.insert(L,n('%s=%s',N,O))end end end;return n('{%s}',table.concat(L,','))end;if y(K)then return n("'%s'",K:gsub("'",[[\']]))end;return tostring(K)end;local P={}P.__index=P;P.__tostring=function(K,Q)local R={}for N in pairs(K)do table.insert(R,N)end;table.sort(R)local L={}for _,N in ipairs(R)do local O=J(K[N])if type(N)=='number'then table.insert(L,n('[%s]=%s',N,O))else table.insert(L,n('%s=%s',N,O))end end;if Q then return n('%s%s',Q,table.concat(L,',\n'..Q))end;return n('{%s}',table.concat(L,','))end;P.__eq=function(S,T)return S.systemId==T.systemId and S.id==T.id and s(S.radius,T.radius)and s(S.center.x,T.center.x)and s(S.center.y,T.center.y)and s(S.center.z,T.center.z)and s(S.GM,T.GM)end;local function U(V,W,X,Y,Z)assert(v(V),'Argument 1 (systemId) must be a number:'..type(V))assert(v(W),'Argument 2 (id) must be a number:'..type(W))assert(v(X),'Argument 3 (radius) must be a number:'..type(X))assert(w(Y),'Argument 4 (worldCoordinates) must be a array or vec3.'..type(Y))assert(v(Z),'Argument 5 (GM) must be a number:'..type(Z))return setmetatable({systemId=q(V),id=q(W),radius=q(X),center=vec3(Y),GM=q(Z)},P)end;local MapPosition={}MapPosition.__index=MapPosition;MapPosition.__tostring=function(p)return n('::pos{%d,%d,%s,%s,%s}',p.systemId,p.id,H(p.latitude*E),H(p.longitude*E),H(p.altitude))end;MapPosition.__eq=function(S,T)return S.id==T.id and S.systemId==T.systemId and s(S.latitude,T.latitude)and s(S.altitude,T.altitude)and(s(S.longitude,T.longitude)or s(S.latitude,math.pi/2)or s(S.latitude,-math.pi/2))end;local function a0(a1,W,a2,a3,a4)local V=a1;if y(a1)and not a3 and not a4 and not W and not a2 then V,W,a2,a3,a4=stringmatch(a1,G)assert(V,'Argument 1 (position string) is malformed.')else assert(v(V),'Argument 1 (systemId) must be a number:'..type(V))assert(v(W),'Argument 2 (id) must be a number:'..type(W))assert(v(a2),'Argument 3 (latitude) must be in degrees:'..type(a2))assert(v(a3),'Argument 4 (longitude) must be in degrees:'..type(a3))assert(v(a4),'Argument 5 (altitude) must be in meters:'..type(a4))end;V=q(V)W=q(W)a2=q(a2)a3=q(a3)a4=q(a4)if W==0 then return setmetatable({latitude=a2,longitude=a3,altitude=a4,id=W,systemId=V},MapPosition)end;return setmetatable({latitude=D*o(a2,-90,90),longitude=D*(a3%360),altitude=a4,id=W,systemId=V},MapPosition)end;local a5={}a5.__index=a5;a5.__tostring=function(K,Q)local a6=Q and Q..'  'local a7={}local R={}for N in pairs(K)do table.insert(R,N)end;table.sort(R)for _,a8 in ipairs(R)do bdy=K[a8]local a9=P.__tostring(bdy,a6)if Q then table.insert(a7,n('[%s]={\n%s\n%s}',a8,a9,Q))else table.insert(a7,n('  [%s]=%s',a8,a9))end end;if Q then return n('\n%s%s%s',Q,table.concat(a7,',\n'..Q),Q)end;return n('{\n%s\n}',table.concat(a7,',\n'))end;local function aa(ab)local l={}local pid;for _,A in pairs(ab)do local W=A.planetarySystemId;if type(W)~='number'then error('Invalid planetary s ID: '..tostring(W))elseif pid and W~=pid then error('Mistringmatch planetary s IDs: '..W..' and '..pid)end;local ac=A.bodyId;if type(ac)~='number'then error('Invalid body ID: '..tostring(ac))elseif l[ac]then error('Duplicate body ID: '..tostring(ac))end;setmetatable(A.center,getmetatable(vec3.unit_x))l[ac]=setmetatable(A,P)pid=W end;return setmetatable(l,a5)end;PlanetaryReference={}local function ad(ab)return setmetatable({galaxyAtlas=ab or{}},PlanetaryReference)end;PlanetaryReference.__index=function(x,i)if type(i)=='number'then local a=x.galaxyAtlas[i]return aa(a)end;return rawget(PlanetaryReference,i)end;PlanetaryReference.__pairs=function(K)return function(x,N)local ae,nv=next(x,N)return ae,nv and aa(nv)end,K.galaxyAtlas,nil end;PlanetaryReference.__tostring=function(K)local af={}for _,ag in pairs(K or{})do local ah=ag:getPlanetarySystemId()local ai=a5.__tostring(ag,'    ')table.insert(af,n('  [%s]={%s\n  }',ah,ai))end;return n('{\n%s\n}\n',table.concat(af,',\n'))end;PlanetaryReference.BodyParameters=U;PlanetaryReference.MapPosition=a0;PlanetaryReference.PlanetarySystem=aa;function PlanetaryReference.createBodyParameters(V,W,aj,ak,al,am,an)assert(v(V),'Argument 1 (systemId) must be a number:'..type(V))assert(v(W),'Argument 2 (id) must be a number:'..type(W))assert(v(aj),'Argument 3 (surfaceArea) must be a number:'..type(aj))assert(w(ak),'Argument 4 (aPosition) must be an array or vec3:'..type(ak))assert(w(al),'Argument 5 (verticalAtPosition) must be an array or vec3:'..type(al))assert(v(am),'Argument 6 (altitude) must be in meters:'..type(am))assert(v(an),'Argument 7 (gravityAtPosition) must be number:'..type(an))local X=r(aj/4/math.pi)local distance=X+am;local ao=vec3(ak)+distance*vec3(al)local Z=an*distance*distance;return U(V,W,X,ao,Z)end;PlanetaryReference.isMapPosition=B;function PlanetaryReference:getPlanetarySystem(a1)if i==nil then i=0 end;if nv==nil then nv=0 end;local V=a1;if B(a1)then V=a1.systemId end;if type(V)=='number'then local a=self.galaxyAtlas[i]if a then if getmetatable(nv)~=a5 then a=aa(a)end;return a end end end;function a5:sizeCalculator(ap)return 1.05*ap.radius end;function a5:castIntersections(aq,ar,as,at,au,av)local aw={}if au then for _,ap in pairs(au)do table.insert(aw,ap)end else aw=planetAtlas end;if not av then table.sort(aw,function(ax,ay)local az=ax.center;local aA=ay.center;return(az.x-aq.x)^2+(az.y-aq.y)^2+(az.z-aq.z)^2<(aA.x-aq.x)^2+(aA.y-aq.y)^2+(aA.z-aq.z)^2 end)end;local aB=ar:normalize()for _,ap in ipairs(aw)do local aC=ap.center-aq;local X;if as then X=as(ap)else X=self:sizeCalculator(ap)end;local aD=aC:dot(aB)local aE=aD^2-(aC:len2()-X^2)if aE>=0 then local aF=r(aE)local aG=aD+aF;local aH=aD-aF;if aH>0 then return ap,aG,aH elseif aG>0 then return ap,aG,nil end end end;return nil,nil,nil end;function a5:closestBody(aI)assert(type(aI)=='table','Invalid coordinates.')local aJ,ap;local aK=vec3(aI)for _,aL in pairs(self)do local aM=(aK-aL.center):len()-aL.radius-aL.atmosphereThickness;if(not ap or aM<aJ)and aL.name~="Space"and aL.name~="Aegis"then ap=aL;aJ=aM end end;return ap end;function a5:convertToBodyIdAndWorldCoordinates(a1)local aN=a1;if y(a1)then aN=a0(a1)end;if aN.id==0 then return 0,vec3(aN.latitude,aN.longitude,aN.altitude)end;local aL=self:getBodyParameters(aN)if aL then return aN.id,aL:convertToWorldCoordinates(aN)end end;function a5:getBodyParameters(a1)local W=a1;if B(a1)then W=a1.id end;assert(v(W),'Argument 1 (id) must be a number:'..type(W))return self[W]end;function a5:getPlanetarySystemId()local _,A=next(self)return A and A.systemId end;function P:convertToMapPosition(Y)assert(w(Y),'Argument 1 (worldCoordinates) must be an array or vec3:'..type(Y))local aO=vec3(Y)if self.id==0 then return setmetatable({latitude=aO.x,longitude=aO.y,altitude=aO.z,id=0,systemId=self.systemId},MapPosition)end;local aP=aO-self.center;local distance=aP:len()local a4=distance-self.radius;local a2=0;local a3=0;if not s(distance,0)then local aQ=atan(aP.y,aP.x)a3=aQ>=0 and aQ or 2*math.pi+aQ;a2=math.pi/2-math.acos(aP.z/distance)end;return setmetatable({latitude=a2,longitude=a3,altitude=a4,id=self.id,systemId=self.systemId},MapPosition)end;function P:convertToWorldCoordinates(a1)local aN=y(a1)and a0(a1)or a1;if aN.id==0 then return vec3(aN.latitude,aN.longitude,aN.altitude)end;assert(B(aN),'Argument 1 (mapPosition) is not an instance of "MapPosition".')assert(aN.systemId==self.systemId,'Argument 1 (mapPosition) has a different planetary s ID.')assert(aN.id==self.id,'Argument 1 (mapPosition) has a different planetary body ID.')local aR=math.cos(aN.latitude)return self.center+(self.radius+aN.altitude)*vec3(aR*math.cos(aN.longitude),aR*math.sin(aN.longitude),math.sin(aN.latitude))end;function P:getAltitude(Y)return(vec3(Y)-self.center):len()-self.radius end;function P:getDistance(Y)return(vec3(Y)-self.center):len()end;function P:getGravity(Y)local aS=self.center-vec3(Y)local aT=aS:len2()return self.GM/aT*aS/r(aT)end;return setmetatable(PlanetaryReference,{__call=function(_,...)return ad(...)end})end;local function aU(d,b,c,a,r,aV)local Kinematic={}local aW=100;function Kinematic.computeAccelerationTime(aX,aY,aZ)return(aZ-aX)/aY end;function Kinematic.computeDistanceAndTime(aX,aZ,a_,b0,b1,b2)b1=b1 or 0;b2=b2 or 0;local b3=aX<aZ;local b4=b0/(b3 and a_ or-a_)local b5=-b2/a_;local b6=b4+b5;if aX==aZ then return 0,0 elseif b3 and b6<=0 or not b3 and b6>=0 then return-1,-1 end;local b7,b8=0,0;if b4~=0 and b1>0 then local b9=math.pi/b1/2;local A=function(x)return b4*(x/2-b1*math.sin(b9*x)/math.pi)+b5*x+aX end;local ba=b3 and function(a)return a>=aZ end or function(a)return a<=aZ end;b8=2*b1;if ba(A(b8))then local bb=0;while math.abs(b8-bb)>0.25 do local x=(b8+bb)/2;if ba(A(x))then b8=x else bb=x end end end;local bc=2*b4*b1^2/math.pi^2;b7=bc*(math.cos(b9*b8)-1)+(b4+2*b5)*b8^2/4+aX*b8;if b8<2*b1 then return b7,b8 end;aX=A(b8)end;local az=b4+b5;local x=Kinematic.computeAccelerationTime(aX,az,aZ)local bd=aX*x+az*x*x/2;return b7+bd,b8+x end;function Kinematic.computeTravelTime(aX,aY,distance)if distance==0 then return 0 end;if aY~=0 then return(math.sqrt(2*aY*distance+aX^2)-aX)/aY end;assert(aX>0,'Acceleration and initial speed are both zero.')return distance/aX end;return Kinematic end;local function be(d,b,c,a,n,o,q,r,s)local vec3=vec3;local m=m(d,b,c,a,n,o,q,r,s)local function y(a)return type(a)=='string'end;local function w(x)return type(x)=='table'end;Kepler={}Kepler.__index=Kepler;function Kepler:escapeAndOrbitalSpeed(a4)assert(self.body)local distance=a4+self.body.radius;if not s(distance,0)then local orbit=r(self.body.GM/distance)return r(2)*orbit,orbit end;return nil,nil end;function Kepler:orbitalParameters(a1,bf)assert(self.body)assert(w(a1)or y(a1))assert(w(bf))local bg=(y(a1)or m.isMapPosition(a1))and self.body:convertToWorldCoordinates(a1)or vec3(a1)local A=vec3(bf)local bh=bg-self.body.center;local bi=A:len2()local bd=bh:len()local bj=self.body.GM;local bk=((bi-bj/bd)*bh-bh:dot(A)*A)/bj;local az=bj/(2*bj/bd-bi)local bl=bk:len()local aB=bk:normalize()local bm=az*(1-bl)local bn=az*(1+bl)local bo=bm*aB+self.body.center;local bp=bl<=1 and-bn*aB+self.body.center or nil;local bq=r(az*bj*(1-bl*bl))local br=bp and 2*math.pi*r(az^3/bj)local bs=math.acos(bk:dot(bh)/(bl*bd))if bh:dot(A)<0 then bs=-(bs-2*math.pi)end;local bt=math.acos((math.cos(bs)+bl)/(1+bl*math.cos(bs)))local bu=bt;if bu<0 then bu=bu+2*math.pi end;local bv=bu-bl*math.sin(bu)local bw=0;local bx=0;local by=0;if br~=nil then bw=bv/(2*math.pi/br)bx=br-bw;by=bx+br/2;if bs-math.pi>0 then bx=bw;by=bx+br/2 end;if by>br then by=by-br end end;return{periapsis={position=bo,speed=bq/bm,circularOrbitSpeed=r(bj/bm),altitude=bm-self.body.radius},apoapsis=bp and{position=bp,speed=bq/bn,circularOrbitSpeed=r(bj/bn),altitude=bn-self.body.radius},currentVelocity=A,currentPosition=bg,eccentricity=bl,period=br,eccentricAnomaly=bt,meanAnomaly=bv,timeToPeriapsis=bx,timeToApoapsis=by,trueAnomaly=bs}end;local function bz(bA)local aL=m.BodyParameters(bA.systemId,bA.id,bA.radius,bA.center,bA.GM)return setmetatable({body=aL},Kepler)end;return setmetatable(Kepler,{__call=function(_,...)return bz(...)end})end;local function bB(d,b,c,a,dbHud_1,l,bC,bD,g,q,r,bE,bF,k)local function bG(position)local p=sys:closestBody(position)if(position-p.center):len()>p.radius+p.noAtmosphericDensityAltitude then p=l[0][0]end;return p end;local function bH()local function bI(bJ,bK)return bJ.name<bK.name end;AtlasOrdered={}for N,A in pairs(l[0])do AtlasOrdered[#AtlasOrdered+1]={name=A.name,index=N}end;table.sort(AtlasOrdered,bI)end;local function bL(bM,bN)if not bN then bN=CustomTarget.name end;for N,A in pairs(bM)do if A.name and A.name==bN then return N end end;return-1 end;local function bO()apScrollIndex=AutopilotTargetIndex;if AutopilotTargetIndex==0 then AutopilotTargetName="None"autopilotTargetPlanet=nil;CustomTarget=nil;return true end;local bP=AtlasOrdered[AutopilotTargetIndex].index;local bQ=l[0][bP]if bQ.center then AutopilotTargetName=bQ.name;autopilotTargetPlanet=galaxyReference[0][bP]if CustomTarget~=nil then if atmosDensity==0 then if not bC(widgetMaxBrakeTimeText,widgetMaxBrakeTime)then bD(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if not bC(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)then bD(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if not bC(widgetCurBrakeTimeText,widgetCurBrakeTime)then bD(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if not bC(widgetCurBrakeDistanceText,widgetCurBrakeDistance)then bD(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if not bC(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)then bD(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;if not bC(widgetMaxMassText,widgetMaxMass)then bD(widgetMaxMassText,widgetMaxMass)end;if not bC(widgetTravelTimeText,widgetTravelTime)then bD(widgetTravelTimeText,widgetTravelTime)end;if not bC(widgetTargetOrbitText,widgetTargetOrbit)then bD(widgetTargetOrbitText,widgetTargetOrbit)end end;CustomTarget=nil else CustomTarget=bQ;for _,A in pairs(galaxyReference[0])do if A.name==CustomTarget.planetname then autopilotTargetPlanet=A;AutopilotTargetName=CustomTarget.name;break end end;if not bC(widgetMaxMassText,widgetMaxMass)then bD(widgetMaxMassText,widgetMaxMass)end;if not bC(widgetTravelTimeText,widgetTravelTime)then bD(widgetTravelTimeText,widgetTravelTime)end end;if CustomTarget==nil then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)else AutopilotTargetCoords=CustomTarget.position end;if autopilotTargetPlanet.planetname~="Space"then if autopilotTargetPlanet.hasAtmosphere then AutopilotTargetOrbit=g(autopilotTargetPlanet.radius*(TargetOrbitRadius-1)+autopilotTargetPlanet.noAtmosphericDensityAltitude)else AutopilotTargetOrbit=g(LowOrbitHeight+autopilotTargetPlanet.surfaceMaxAltitude)end else AutopilotTargetOrbit=AutopilotSpaceDistance end;if CustomTarget~=nil and CustomTarget.planetname=="Space"then AutopilotEndSpeed=0 else _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(AutopilotTargetOrbit)end;AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"return true end;local function bR(bS)if not alignTarget and not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit and not Reentry and not finalLand then if bS==nil then AutopilotTargetIndex=AutopilotTargetIndex+1;if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end else AutopilotTargetIndex=AutopilotTargetIndex-1;if AutopilotTargetIndex<0 then AutopilotTargetIndex=#AtlasOrdered end end;if AutopilotTargetIndex==0 then bO()else local bP=AtlasOrdered[AutopilotTargetIndex].index;local bQ=l[0][bP]if bQ and(bQ~=nil and bQ.name=="Space"or iphCondition=="Custom Only"and bQ.center or iphCondition=="No Moons-Asteroids"and(string.find(bQ.name,"Moon")~=nil or string.find(bQ.name,"Asteroid")~=nil))then if bS==nil then bR()else bR(1)end else bO()end end else k("Disengage autopilot before changing Interplanetary Helper")bE("iph","AP")end end;local function bT()local function bU(bV)local positions;if bV then positions=privatelocations else positions=SavedLocations end;local bW=-1;bW=bL(l[0])if bW>-1 then table.remove(l[0],bW)end;bW=-1;bW=bL(positions)if bW~=-1 then k(CustomTarget.name.." saved location cleared")table.remove(positions,bW)end;bR()bH()return positions end;if string.sub(AutopilotTargetName,1,1)=="*"then privatelocations=bU(true)else SavedLocations=bU(false)end end;local function bX(bY,position,bZ,b_)local function c0(bV)if bV then positions=privatelocations else positions=SavedLocations end;if dbHud_1 or bZ or bV then local p=bG(position)local c1={position=position,name=bY,planetname=p.name,gravity=b.getGravityIntensity(),safe=b_}if not bZ then positions[#positions+1]=c1 else for N,A in pairs(l[0])do if A.name and bY==A.name then table.remove(l[0],N)end end end;table.insert(l[0],c1)bH()if bZ then AutopilotTargetIndex=1 end;bO()k("Location saved as "..bY.."("..p.name..")")return positions else k("Databank must be installed to save permanent locations")end end;if string.sub(bY,1,1)=="*"then privatelocations=c0(true)else SavedLocations=c0(false)end end;local c2={}function c2.UpdateAtlasLocationsList()bH()end;function c2.UpdateAutopilotTarget()bO()end;function c2.adjustAutopilotTargetIndex(bS)bR(bS)end;function c2.findAtlasIndex(bM,bN)return bL(bM,bN)end;function c2.UpdatePosition(c3,c4,c5)local function c6(bV)local positions;if bV then positions=privatelocations else positions=SavedLocations end;local bW=bL(positions)if bW~=-1 then if c3~=nil then if bV then c3="*"..c3 end;positions[bW].name=c3;AutopilotTargetIndex=AutopilotTargetIndex-1;bR()elseif c5~=nil then if c5 then local c7=coreAltitude;if c7<1000 then c7=1000 end;positions[bW].agg=bF(c7,0)k(positions[bW].name.." AGG Altitude:"..positions[bW].agg.." saved ("..positions[bW].planetname..")")return elseif c5==false then positions[bW].agg=nil;k(positions[bW].name.." AGG Altitude cleared ("..positions[bW].planetname..")")return end else local c8=positions[bW]if c4 then c8.heading=constructRight:cross(worldVertical)*5000;k(positions[bW].name.." heading saved ("..positions[bW].planetname..")")return elseif c4==false then c8.heading=nil;k(positions[bW].name.." heading cleared ("..positions[bW].planetname..")")return end;c8.gravity=b.getGravityIntensity()c8.position=worldPos;c8.safe=true end;k(positions[bW].name.." position updated ("..positions[bW].planetname..")")else k("Name Not Found")end end;if string.sub(AutopilotTargetName,1,1)=="*"then c6(true)else c6(false)end end;function c2.AddNewLocation(bY,position,bZ,b_)bX(bY,position,bZ,b_)end;function c2.ClearCurrentPosition()bT()end;for N,A in pairs(customlocations)do table.insert(l[0],A)end;if userAtlas then for N,A in pairs(userAtlas)do c2[N]=A end end;bH()if AutopilotTargetIndex>#AtlasOrdered then AutopilotTargetIndex=0 end;c2.UpdateAutopilotTarget()return c2 end;local function c9(b,a,c,radar_1,radar_2,warpdrive,aV,ca,r,cb,q,cc,bE,k)local cd={}local ce={}local cf={XS=13,S=27,M=55,L=110,XL=221}local cg={"Universe","Planet","Asteroid","Static","Dynamic","Space","Alien"}local ch={}local ci=0;local cj;local ck;local cl=0;local cm;local cn={cm}local co="Atmo"local cp;local cq;local cr=0;local cs={}local ct;local cu=0;local cv=table.insert;local cw=-4;local cx={[1]="Operational",[0]="broken",[-1]="jammed",[-2]="obstructed",[-3]="in use"}local cy,cz;local cA,cB;local cC;local cD;local cE;local cF;local cG;local cH;local cI;local function cJ()if radarPanelId~=nil and cr==0 then ca(radarPanelId)a.destroyWidget(cy)a.destroyData(cA)cy,cA,radarPanelId=nil,nil,nil;if cq~=nil then ca(cq)a.destroyWidget(cz)a.destroyData(cB)cq,cz,cB=nil,nil,nil end else if cr==1 then cq=a.createWidgetPanel("PeriWinkle")cz=a.createWidget(cq,'periscope')cB=cm.getWidgetDataId()a.addDataToWidget(cB,cz)end;if radarPanelId==nil and ci>0 then radarPanelId=a.createWidgetPanel(co)cy=a.createWidget(radarPanelId,'radar')cA=cm.getWidgetDataId()a.addDataToWidget(cA,cy)end;cr=0 end end;local function cK()local function cL(cM,cN,cO,cP,cQ,cR,cS,cT)cN,cP,cR,cT=vec3(cN),vec3(cP),vec3(cR),vec3(cT)local cU,cV,cW=cM*cM,cO*cO,cQ*cQ;local bi=cP-cN;local cX=bi:normalize()local cY=bi:len()local cZ=cR-cN;local c_=(cZ-cZ:project_on(cX)):normalize()local d0,d1=cZ:dot(cX),cZ:dot(c_)local d2=d0*d0+d1*d1;local d3=cX:cross(c_)local d4=(cU-cV+cY*cY)/(2*cY)local d5=(cU-cW+d2-2*d0*d4)/(2*d1)local C=cU-d4^2-d5^2;local d6=r(C)local d7=cN+cX*d4+c_*d5+d3*d6;local d8=cN+cX*d4+c_*d5-d3*d6;if aV((cT-d7):len()-cS)<aV((cT-d8):len()-cS)then return d7 else return d8 end end;local function d9(da,bd,db)local dc=da.pts;local bW=#dc;local dd=da.ref;if bW>3 then local de,df,dg,dh=dc[bW],dc[bW-1],dc[bW-2],dc[bW-3]da.ref=db;local bg=cL(de[1],de[2],df[1],df[2],dg[1],dg[2],dh[1],dh[2])local d4,d5,d6=bg.x,bg.y,bg.z;if d4==d4 and d5==d5 and d6==d6 then d4=d4+dd[1]d5=d5+dd[2]d6=d6+dd[3]local di=vec3(d4,d5,d6)da.center=di;if da.lastPos then if(da.lastPos-di):len()<2 then local dj=(di-vec3(db)):len()if aV(dj-bd)<10 then da.skipCalc=true end end end;da.lastPos=di end;da.pts={}else local dk={db[1]-dd[1],db[2]-dd[2],db[3]-dd[3]}dc[bW+1]={bd,dk}end end;if radar_1 or radar_2 then RADAR.assignRadar()end;if cm then if#ct>0 then local dl,dm=0,0;local dn=velMag*10;local nearPlanet=nearPlanet;cl,ck=0,0;ce={}for _,A in pairs(ct)do local distance=cG(A)if distance>0.0 then if cC(A)then cv(ce,A)end;if not notPvPZone and warpdrive and distance<EmergencyWarp and warpdrive.getStatus()==15 then k("INITIATING WARP")msgTimer=7;warpdrive.initiate()end;local dp=AbandonedRadar and cE(A)if CollisionSystem or dp then local dq=cH(A)local dr=cf[dq]local ds=cD(A)if dp or distance<dn and(dr>27 or ds==4 or ds==6)then cl=cl+1;local db={worldPos["x"],worldPos["y"],worldPos["z"]}local da=cs[A]if da==nil then dr=dr+cc;cs[A]={pts={},ref=db,name=cF(A),i=0,radius=dr,skipCalc=false}da=cs[A]end;if not da.skipCalc then if dp or ds==4 or ds==6 then da.center=vec3(cI(A))da.skipCalc=true else d9(da,distance,db)dm=dm+1 end;if dp and not da.abandoned then local time=a.getArkTime()if cu+5<time then cu=time;bE("abRdr","RD")end;a.print("Abandoned Construct: "..da.name.." ("..dq.." "..cg[ds]..") at ::pos{0,0,"..da.center.x..","..da.center.y..","..da.center.z.."}")k("Abandoned Radar Contact ("..dq.." "..cg[ds]..") detected")da.abandoned=true end else cv(ch,da)end end;dl=dl+1;if dl>300 or dm>30 then coroutine.yield()dl,dm=0,0 end end end end;ck=#ch;if ck>0 and(velMag>20 or BrakeLanding)then local ap,dt,du,dv;local dw=0;local dx=galaxyReference:getPlanetarySystem(0)dv=constructVelocity:normalize()while dw<ck do coroutine.yield()local dy={table.unpack(ch,dw,math.min(dw+75,ck))}ap,dt,du=dx:castIntersections(worldPos,dv,nil,nil,dy,true)if ap and du then collisionTarget={ap,dt,du}break end;dw=dw+75 end;if not ap then collisionTarget=nil end else collisionTarget=nil end;ch={}cj=cm.getTargetId()end end end;local function dz()if cm then co="Atmo"if string.find(cm.getName(),"Space")then co="Space"end end end;function cd.pickType()dz()end;function cd.assignRadar()if radar_2 and cw~=1 then if cw==-1 then if cm==radar_2 then cm=radar_1 else cm=radar_2 end end;cn={cm}cC=cm.hasMatchingTransponder;cD=cm.getConstructKind;cE=cm.isConstructAbandoned;cF=cm.getConstructName;cG=cm.getConstructDistance;cH=cm.getConstructCoreSize;cI=cm.getConstructWorldPos;ct=cm.getConstructIds()dz()else ct=cm.getConstructIds()end;cw=cm.getOperationalState()end;function cd.UpdateRadar()local dA=coroutine.status(cp)if dA=="suspended"then local O,dB=coroutine.resume(cp)if dB then a.print("ERROR UPDATE RADAR: "..dB)end elseif dA=="dead"then cp=coroutine.create(cK)local O,dB=coroutine.resume(cp)end end;function cd.GetRadarHud(dC,dD,radarX,radarY)local dE,k;local F=ck or 0;ci=#ct;if ci>0 then if CollisionSystem then k=F.."/"..cl.." Known/InRange : "..ci.." Total"else k="Radar Contacts: "..ci end;dE=cb(radarX,radarY,k,"pbright txtbig txtmid")if#ce>0 then dE=dE..cb(dC,dD,"Friendlies In Range","pbright txtbig txtmid")for N,A in pairs(ce)do dD=dD+20;dE=dE..cb(dC,dD,cm.getConstructName(A),"pdim txtmid")end end;local dF=#cm.getIdentifiedConstructIds()if cq==nil and dF>0 then cr=1;RADAR.ToggleRadarPanel()end;if cq~=nil and dF==0 then RADAR.ToggleRadarPanel()end;if radarPanelId==nil then if showHud then RADAR.ToggleRadarPanel()end end else if cw~=1 then dE=cb(radarX,radarY,co.." Radar: "..cx[cw],"pbright txtbig txtmid")else dE=cb(radarX,radarY,"Radar: No "..co.." Contacts","pbright txtbig txtmid")end;if radarPanelId~=nil then cr=0;RADAR.ToggleRadarPanel()end end;return dE end;function cd.GetClosestName(bY)if cm then local dG=cm.getConstructName(cm.getConstructIds()[1])if dG then bY=bY.." "..dG end end;return bY end;function cd.ToggleRadarPanel()cJ()end;function cd.ContactTick()if not contactTimer then contactTimer=0 end;if time>contactTimer+10 then k("Radar Contact")bE("rdrCon","RC")contactTimer=time end;c.stopTimer("contact")end;function cd.onEnter(W)if cm and not inAtmo and not notPvPZone then c.setTimer("contact",0.1)end end;function cd.onLeave(W)if cm and CollisionSystem then if#cs>650 then W=tostring(W)cs[W]=nil end end end;local function dH()cm=nil;if radar_2 and radar_2.getOperationalState()then cm=radar_2 else cm=radar_1 end;cw=cm.getOperationalState()cC=cm.hasMatchingTransponder;cD=cm.getConstructKind;cE=cm.isConstructAbandoned;cF=cm.getConstructName;cG=cm.getConstructDistance;cH=cm.getConstructCoreSize;cI=cm.getConstructWorldPos;cn={cm}ct=cm.getConstructIds()dz()cp=coroutine.create(cK)if userRadar then for N,A in pairs(userRadar)do cd[N]=A end end end;dH()return cd end;local function dI(shield,stringmatch,g,k)local dJ={}local dK=shield.getResistancesCooldown()local function dL()local dM=shield.isActive()if AutoShieldToggle then if not notPvPZone and not dM and not shield.isVenting()then shield.toggle()elseif notPvPZone and dM then shield.toggle()end end end;local function dN()local dO=shield.getStressRatioRaw()local dP=0.5999;if dO[1]==0.0 and dO[2]==0.0 and dO[3]==0.0 and dO[4]==0.0 then return end;local dQ=shield.setResistances(dP*dO[1],dP*dO[2],dP*dO[3],dP*dO[4])if dQ then k("Shield Resistances updated")else k("Value Exceeded. Failed to update Shield Resistances")end end;function dJ.shieldTick()shieldPercent=g(0.5+shield.getShieldHitpoints()*100/shield.getMaxShieldHitpoints())dL()dK=shield.getResistancesCooldown()if dK==0 and shieldPercent<AutoShieldPercent then dN()end end;function dJ.setResist(dR)if not shield then k("No shield found")return elseif dR==nil or dK>0 then k("Usable once per min.  Usage: /resist 0.15, 0.15, 0.15, 0.15")return end;local F=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local G=F..', '..F..', '..F..', '..F;local dS,dT,dU,dV=stringmatch(dR,G)if dV==nil or dS+dT+dU+dV>0.6 then k("Improperly formatted or total exceeds 0.6")return end;if shield.setResistances(dS,dT,dU,dV)then k("Shield Resistances set")else k("Resistance setting failed.")end end;function dJ.ventShield()local dW=shield.getVentingCooldown()if dW>0 then k("Cannot vent again for "..dW.." seconds")return end;if shield.getShieldHitpoints()<shield.getMaxShieldHitpoints()then shield.startVenting()k("Shields Venting Enabled - NO SHIELDS WHILE VENTING")else k("Shields already at max hitpoints")end end;if userShield then for N,A in pairs(userShield)do dJ[N]=A end end;return dJ end;local function dX(d,b,c,a,l,antigrav,hover,shield,warpdrive,weapon,aV,g,n,dY,h,dZ,d_,atan,f,o,e0,bD,bC,ca,e1,r,bF,cb,bE,e2,e3,e4,e5,e6,e7,k)local j=DUConstruct;local e8=9.80665;local e9={}local ea={}local eb={}local ec={}local ed=nil;local ee=nil;local ef=nil;local eg=false;local eh="none"local ei=""local ej=55;local ek=0;local el=0;local em=nil;local en=SafeR;local eo=SafeG;local ep=SafeB;local eq=[[rgb(]]..g(en+0.5)..","..g(eo+0.5)..","..g(ep+0.5)..[[)]]local er=[[rgb(]]..g(en*0.9+0.5)..","..g(eo*0.9+0.5)..","..g(ep*0.9+0.5)..[[)]]local es=0;local et=0;local eu=""local ev=f()local ew=false;local ex=false;local cm=false;local ey=""local ez=""local eA=""local function eB(A)if ResolutionX==1920 then return A else return bF(ResolutionX*A/1920,0)end end;local function eC(A)if ResolutionY==1080 then return A else return bF(ResolutionY*A/1080,0)end end;local function eD()return not e1()and userControlScheme~="keyboard"and not d_()end;local dE=""local eE=""local eF=""local function eG(eH,a4)if vSpdMeterX==0 and vSpdMeterY==0 then return end;if a4<200000 and not inAtmo or a4 and inAtmo then local eI=0;if aV(vSpd)>1 then eI=45*math.log(aV(vSpd),10)if vSpd<0 then eI=-eI end end;eH[#eH+1]=n([[
                                <g class="pbright txt txtvspd" transform="translate(%d %d) scale(0.6)">
                                        <text x="55" y="-41">1000</text>
                                        <text x="10" y="-65">100</text>
                                        <text x="-45" y="-45">10</text>
                                        <text x="-73" y="3">O</text>
                                        <text x="-45" y="52">-10</text>
                                        <text x="10" y="72">-100</text>
                                        <text x="55" y="50">-1000</text>
                                        <text x="85" y="0" class="txtvspdval txtend">%d m/s</text>
                                    <g class="linethick">
                                        <path d="m-41 75 2.5-4.4m17 12 1.2-4.9m20 7.5v-10m-75-34 4.4-2.5m-12-17 4.9-1.2m17 40 7-7m-32-53h10m34-75 2.5 4.4m17-12 1.2 4.9m20-7.5v10m-75 34 4.4 2.5m-12 17 4.9 1.2m17-40 7 7m-32 53h10m116 75-2.5-4.4m-17 12-1.2-4.9m40-17-7-7m-12-128-2.5 4.4m-17-12-1.2 4.9m40 17-7 7"/>
                                        <circle r="90" />
                                    </g>
                                    <path transform="rotate(%d)" d="m-0.094-7c-22 2.2-45 4.8-67 7 23 1.7 45 5.6 67 7 4.4-0.068 7.8-4.9 6.3-9.1-0.86-2.9-3.7-5-6.8-4.9z" />
                                </g>
                            ]],vSpdMeterX,vSpdMeterY,g(vSpd),g(eI))end;return eH end;local function eJ(eH,a4,nearPlanet)local eK=altMeterX;local eL=altMeterY;if eK==0 and eL==0 then return end;local eM=78;local eN=19;local eO=abvGndDet;if abvGndDet~=-1 then eH[#eH+1]=cb(eK+eM,eL+eN+20,n("AGL: %.1fm",abvGndDet),"pdim altsm txtend")end;if nearPlanet and(a4<200000 and not inAtmo or a4 and inAtmo)then eH[#eH+1]=cb(eK+eM,eL-10,n("%s",planet.name),"pdim altsm txtend")table.insert(eH,n([[
                                <g class="pdim">                        
                                    <rect class="line" x="%d" y="%d" width="%d" height="%d"/> 
                                    <clipPath id="alt"><rect class="line" x="%d" y="%d" width="%d" height="%d"/></clipPath>
                                    <g clip-path="url(#alt)">]],eK-1,eL-4,eM+2,eN+6,eK+1,eL-1,eM-4,eN))local bW=0;local eP=1;local eQ=0;local eR=a4<0;local eS=a4<planet.surfaceMaxAltitude;local eT=9;if eR then eT=0 end;local a4=aV(a4)while bW<6 do local eU=11;local eV=16;local eW=9;local eX=14;local eY="altsm"if bW>2 then eV=eV+3;eU=eU+2;eX=eX+2;eW=eW-6;eY="altbig"end;if eR then eY=eY.." red"elseif eS then eY=eY.." orange"end;local eZ=a4/eP%10;local e_=g(eZ)local f0=g((e_+1)%10)local f1=eQ;if bW==0 then f1=eZ-e_;if eR then f1=1-f1 end end;if eR and(bW==0 or eQ~=0)then local bZ=f0;f0=e_;e_=bZ end;local f2=eV*(f1-1)local f3=f2+eV;local d4=eK+eW+(6-bW)*eU;local d5=eL+eX;eH[#eH+1]=cb(d4,d5+f2,f0,eY)eH[#eH+1]=cb(d4,d5+f3,e_,eY)bW=bW+1;eP=eP*10;if e_==eT then eQ=f1 else eQ=0 end end;table.insert(eH,[[</g></g>]])end end;local function f4(bf)local f5=-math.deg(atan(bf.y,bf.z))+180;f5=f5-90;if f5<0 then f5=360+f5 end;if f5>180 then f5=-180+f5-180 end;return-f5 end;local function f6(bf)local f7=math.deg(atan(bf.y,bf.x))-90;if f7<-180 then f7=360+f7 end;return f7 end;local function f8(eH,bf,f9,centerX,centerY)if f9>5 and not inAtmo or f9>ej then local fa=circleRad;local fb=20;local fc=20;local fd=f4(bf)local fe=f6(bf)local ff=14;local fg=ff/2;local fh=-fe/fc*fa;local fi=fd/fb*fa;local d4=centerX+fh;local d5=centerY+fi;local distance=r(fh^2+fi^2)local fj=[[<circle
                            cx="]]..d4 ..[["
                            cy="]]..d5 ..[["
                            r="]]..fg/ff..[["
                            style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                        <circle
                            cx="]]..d4 ..[["
                            cy="]]..d5 ..[["
                            r="]]..fg..[["
                            style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                        <path
                            d="M ]]..d4-ff..[[,]]..d5 ..[[ h ]]..fg..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..d4+fg..[[,]]..d5 ..[[ h ]]..fg..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />
                        <path
                            d="M ]]..d4 ..[[,]]..d5-ff..[[ v ]]..fg..[["
                            style="stroke:#d7fe00;stroke-opacity:1" />]]if distance<fa then eH[#eH+1]=fj else local eI=atan(fi,fh)local fk=4;local fl=centerX+fa*math.cos(eI)local fm=centerY+fa*math.sin(eI)eH[#eH+1]=n('<g transform="rotate(%f %f %f)"><rect x="%f" y="%f" width="%f" height="%f" stroke="#d7fe00" fill="#d7fe00" /><path d="M %f %f l %f %f l %f %f z" fill="#d7fe00" stroke="#d7fe00"></g>',eI*180/math.pi,fl,fm,fl-fk,fm-fk/2,fk*2,fk,fl+fk,fm-fk,fk,fk,-fk,fk)end;if not inAtmo then local fn=vec3(bf)fd=f4(-fn)fe=f6(-fn)fh=-fe/fc*fa;fi=fd/fb*fa;d4=centerX+fh;d5=centerY+fi;distance=r(fh^2+fi^2)if distance<fa then local fo=[[<circle
                                    cx="]]..d4 ..[["
                                    cy="]]..d5 ..[["
                                    r="]]..fg..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..d4 ..[[,]]..d5-ff..[[ v ]]..fg..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" id="l"/>
                                <use
                                    xlink:href="#l"
                                    transform="rotate(120,]]..d4 ..[[,]]..d5 ..[[)" />
                                <use
                                    xlink:href="#l"
                                    transform="rotate(-120,]]..d4 ..[[,]]..d5 ..[[)" />
                                <path
                                    d="M ]]..d4-fg..[[,]]..d5 ..[[ h ]]..ff..[["
                                    style="stroke-width:0.5;stroke:#d7fe00;stroke-opacity:1"
                                    transform="rotate(-45,]]..d4 ..[[,]]..d5 ..[[)" id="c"/>
                                <use
                                    xlink:href="#c"
                                    transform="rotate(-90,]]..d4 ..[[,]]..d5 ..[[)"/>]]eH[#eH+1]=fo end end end end;local function fp(eH,eA,fq,fr)if throtPosX==0 and throtPosY==0 then return end;fq=g(fq+0.5)local fs=throtPosY+10;local ft=throtPosY+20;if d_()and not RemoteHud then fs=55;ft=65 end;local fu="CRUISE"local c="km/h"local O=fr;if string.find(eA,"TRAVEL")or string.find(eA,"AUTOPILOT")then fu="THROT"c="%"O=fq;local fv="dim"if fq<0 then fv="red"end;eH[#eH+1]=n([[<g class="%s">
                                <path class="linethick" d="M %d %d L %d %d L %d %d L %d %d"/>
                                <g transform="translate(0 %.0f)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g>]],fv,throtPosX-7,throtPosY-50,throtPosX,throtPosY-50,throtPosX,throtPosY+50,throtPosX-7,throtPosY+50,1-aV(fq),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)end;eH[#eH+1]=cb(throtPosX+10,fs,fu,"pbright txtstart")eH[#eH+1]=cb(throtPosX+10,ft,n("%.0f %s",O,c),"pbright txtstart")if inAtmo and AtmoSpeedAssist and throttleMode and ThrottleLimited then fq=g(calculatedThrottle*100+0.5)local fv="red"if fq<0 then fv="red"end;eH[#eH+1]=n([[<g class="%s">
                                <g transform="translate(0 %d)">
                                    <polygon points="%d,%d %d,%d %d,%d"/>
                                </g></g>]],fv,1-aV(fq),throtPosX-10,throtPosY+50,throtPosX-15,throtPosY+53,throtPosX-15,throtPosY+47)eH[#eH+1]=cb(throtPosX+10,fs+40,"LIMIT","pbright txtstart")eH[#eH+1]=cb(throtPosX+10,ft+40,fq.."%","pbright txtstart")end;if inAtmo and AtmoSpeedAssist or Reentry then eH[#eH+1]=cb(throtPosX+10,fs-40,"LIMIT: "..adjustedAtmoSpeedLimit.." km/h","dim txtstart")elseif not inAtmo and Autopilot then eH[#eH+1]=cb(throtPosX+10,fs-40,"LIMIT: "..g(adjMaxGameVelocity*3.6+0.5).." km/h","dim txtstart")end end;local function fw(eH,fx)if throtPosX==0 and throtPosY==0 then return end;local fy=throtPosY-10;local fz=throtPosX+10;eH[#eH+1]=cb(0,0,"","pdim txt txtend")if d_()and not RemoteHud then fy=75 end;eH[#eH+1]=cb(fz,fy,g(fx).." km/h","pbright txtbig txtstart")end;local fA=40;local function fB(eH)eH[#eH+1]=cb(eB(150),eC(1070),n("ARCH Hud Version: %.3f",VERSION_NUMBER),"hudver")eH[#eH+1]=[[<g class="warnings">]]if c.isMouseControlActivated()then eH[#eH+1]=cb(eB(960),eC(550),"Warning: Invalid Control Scheme Detected","warnings")eH[#eH+1]=cb(eB(960),eC(600),"Keyboard Scheme must be selected","warnings")eH[#eH+1]=cb(eB(960),eC(650),"Set your preferred scheme in Lua Parameters instead","warnings")end;local fC=eB(960)local fD=eC(860)local fE=eC(880)local fF=eC(900)local fG=eC(960)local fH=eC(200)local fI=eC(250)local fJ=eC(960)if d_()and not RemoteHud then fD=eC(135)fE=eC(155)fF=eC(175)fH=eC(115)fI=eC(95)end;if BrakeIsOn then local fK=""if type(BrakeIsOn)=="string"then fK="-"..BrakeIsOn end;eH[#eH+1]=cb(fC,fD,"Brake Engaged"..fK,"warnings")elseif brakeInput2>0 then eH[#eH+1]=cb(fC,fD,"Auto-Brake Engaged","warnings","opacity:"..brakeInput2)end;if inAtmo and stalling and abvGndDet==-1 then if not Autopilot and not VectorToTarget and not BrakeLanding and not antigravOn and not VertTakeOff and not AutoTakeoff then eH[#eH+1]=cb(fC,fH+50,"** STALL WARNING **","warnings")bE("stall","SW",2)end end;if ReversalIsOn then eH[#eH+1]=cb(fC,fH+90,"Flight Assist in Progress","warnings")end;if gyroIsOn then eH[#eH+1]=cb(fC,fJ,"Gyro Enabled","warnings")end;if ECU then fA=fA-1;if fA>20 then eH[#eH+1]=cb(fC,fJ-20,"ECU Enabled","warnings")elseif fA<0 then fA=40 end end;if GearExtended then if hasGear then eH[#eH+1]=cb(fC,fE,"Gear Extended","warn")else eH[#eH+1]=cb(fC,fE,"Landed (G: Takeoff)","warnings")end end;if abvGndDet>-1 and(not antigravOn or coreAltitude<100)then local fL=e4(d:getTargetGroundAltitude())eH[#eH+1]=cb(fC,fF,"Hover Height: "..fL,"warn")end;if isBoosting then eH[#eH+1]=cb(fC,fG+20,"ROCKET BOOST ENABLED","warn")end;if antigrav and not ExternalAGG and antigravOn and AntigravTargetAltitude~=nil then local fM="warnings"if aV(coreAltitude-antigrav.getBaseAltitude())<501 then fM="warn"end;eH[#eH+1]=cb(fC,fH+40,n("Target Altitude: %d Singularity Altitude: %d",g(AntigravTargetAltitude),g(antigrav.getBaseAltitude())),fM)end;if Autopilot and AutopilotTargetName~="None"then eH[#eH+1]=cb(fC,fH,"Autopilot "..AutopilotStatus,"warn")elseif LockPitch~=nil then eH[#eH+1]=cb(fC,fH+20,n("LockedPitch: %d",g(LockPitch)),"warn")elseif followMode then eH[#eH+1]=cb(fC,fH+20,"Follow Mode Engaged","warn")elseif Reentry or finalLand then eH[#eH+1]=cb(fC,fH+20,"Re-entry in Progress","warn")end;if AltitudeHold or VertTakeOff then local fL=e4(HoldAltitude,2)if VertTakeOff then if antigravOn then fL=e4(antigrav.getBaseAltitude(),2).." AGG singularity height"end;eH[#eH+1]=cb(fC,fH,"VTO to "..fL,"warn")elseif(AutoTakeoff or spaceLaunch)and not IntoOrbit then if spaceLaunch then eH[#eH+1]=cb(fC,fH,"Takeoff to "..AutopilotTargetName,"warn")else eH[#eH+1]=cb(fC,fH,"Takeoff to "..fL,"warn")end;if BrakeIsOn and not VertTakeOff then eH[#eH+1]=cb(fC,fH+80,"Throttle Up and Disengage Brake For Takeoff","crit")end else eH[#eH+1]=cb(fC,fH,"Altitude Hold: "..n("%.1fm",HoldAltitude),"warn")end end;if VertTakeOff and(antigrav~=nil and antigrav)then if atmosDensity>0.1 then eH[#eH+1]=cb(fC,fH+20,"Beginning ascent","warn")elseif atmosDensity<0.09 and atmosDensity>0.05 then eH[#eH+1]=cb(fC,fH+20,"Aligning trajectory","warn")elseif atmosDensity<0.05 then eH[#eH+1]=cb(fC,fH+20,"Leaving atmosphere","warn")end end;if IntoOrbit then if orbitMsg~=nil then eH[#eH+1]=cb(fC,fH,orbitMsg,"warn")end end;if BrakeLanding then local fN="Brake Landing"if alignHeading then fN=fN.."-Aligning"end;if apBrk then fN=fN.."-Drift Limited"end;eH[#eH+1]=cb(fC,fH,fN,"warnings")end;if ProgradeIsOn then eH[#eH+1]=cb(fC,fH+20,"Prograde Alignment","crit")end;if RetrogradeIsOn then eH[#eH+1]=cb(fC,fH,"Retrograde Alignment","crit")end;if collisionAlertStatus then local type;if string.find(collisionAlertStatus,"COLLISION")then type="warnings"else type="crit"end;eH[#eH+1]=cb(fC,fI+20,collisionAlertStatus,type)elseif atmosDensity==0 and not Autopilot then local fO,fP=AP.checkLOS(constructVelocity:normalize())if fP~=nil and velMag>0 then local fL=e4(fP)local travelTime=Kinematic.computeTravelTime(velMag,0,fP)local fQ="Collision"if fO.noAtmosphericDensityAltitude>0 then fQ="Atmosphere"end;eH[#eH+1]=cb(fC,fI+20,fO.name.." "..fQ.." "..e5(travelTime).." In "..fL,"crit")end end;if VectorToTarget and not IntoOrbit then eH[#eH+1]=cb(fC,fH+60,VectorStatus,"warn")end;if showHud and DisplayOdometer then eH[#eH+1]=ez end;return eH end;local function fR(f9)return g(bF(f9*3.6,0)+0.5).." km/h"end;local function fS(bW)local bY=AutopilotTargetName;if bW~=nil and type(bW)=="number"then if bW==0 then return"None"end;bY=AtlasOrdered[bW].name end;if bY==nil then bY=CustomTarget.name end;if bY==nil then bY="None"end;return bY end;local function fT(eH)local fU=AP.routeWP(true)if not fU or#fU==0 then return end;local d4=eB(960)local d5=eC(360)if Autopilot or VectorToTarget then eH[#eH+1]=cb(d4,d5,"REMAINING ROUTE","pdim txtmid size20")else eH[#eH+1]=cb(d4,d5,"LOADED ROUTE","pdim txtmid size20")end;for N,i in pairs(fU)do d5=d5+20;eH[#eH+1]=cb(d4,d5,N..". "..fU[N],"pdim txtmid size20")end end;local function fV(eH)local fW=OrbitMapX;local fX=OrbitMapY;local fY=OrbitMapSize;local fZ=4;local f_=15;local d4=0;local d5=0;local g0,g1,g2,g3;local g4;local function g5(type)local c7,time,f9,g6,eY,g7;if type=="Periapsis"then c7=g4.periapsis.altitude;time=g4.timeToPeriapsis;f9=g4.periapsis.speed;eY="txtend"g6=12;g7=math.min(d4,fW+fY-planet.radius/g2-fZ*2)else c7=g4.apoapsis.altitude;time=g4.timeToApoapsis;f9=g4.apoapsis.speed;g6=-12;eY="txtstart"g7=d4 end;if velMag<1 then time=0 end;eH[#eH+1]=n([[<line class="pdim linethin" style="stroke:white" x1="%f" y1="%f" x2="%f" y2="%f"/>]],g7+g6,d5-5,d4,d5-5)eH[#eH+1]=n([[<line class="pdim linethin" x1="%f" y1="%f" x2="%f" y2="%f"/>]],g7-g6*4,d5+2,d4,d5+2)eH[#eH+1]=cb(g7,d5,type,eY)d4=g7-g6*2;d5=d5+f_;local fL=e4(c7)eH[#eH+1]=cb(d4,d5,fL,eY)d5=d5+f_;eH[#eH+1]=cb(d4,d5,e5(time),eY)d5=d5+f_;eH[#eH+1]=cb(d4,d5,fR(f9),eY)end;local g8=fY*1.5;if SelectedTab=="INFO"then g8=25*10 end;if SelectedTab=="ORBIT"and coreAltitude<planet.spaceEngineMinAltitude then return eH end;if SelectedTab~="HIDE"then eH[#eH+1]=[[<g class="pbright txtorb txtmid">]]eH[#eH+1]=n('<rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />',fY*2,g8,fW,fX)eH[#eH+1]=n([[<clippath id="orbitRect">
                                                            <rect width="%f" height="%d" rx="10" ry="10" x="%d" y="%d" class="dimfill brightstroke" style="stroke-width:3;fill-opacity:0.3;" />
                                                            </clippath>]],fY*2,g8,fW,fX)end;local g9=fY*1.5;local ga=fY*2;local gb=g9/2;local gc=fY;local gd=fW+gc;local ge=fX+gb;local gf=fW+ga;local gg=fX+g9;if SelectedTab=="ORBIT"then fX=fX+fZ;g0=fY/2;g3=0;g4={}g4.periapsis={}g4.apoapsis={}if orbit~=nil then if orbit.periapsis~=nil then g4.periapsis.altitude=orbit.periapsis.altitude;g4.periapsis.speed=orbit.periapsis.speed end;if orbit.apoapsis~=nil then g4.apoapsis.altitude=orbit.apoapsis.altitude;g4.apoapsis.speed=orbit.apoapsis.speed end;g4.period=orbit.period;g4.eccentricity=orbit.eccentricity;g4.timeToApoapsis=orbit.timeToApoapsis;g4.timeToPeriapsis=orbit.timeToPeriapsis;g4.eccentricAnomaly=orbit.eccentricAnomaly;g4.trueAnomaly=orbit.trueAnomaly end;if g4.periapsis==nil then g4.periapsis={}g4.periapsis.altitude=-planet.radius;g4.periapsis.speed=adjMaxGameVelocity end;if g4.eccentricity==nil then g4.eccentricity=1 end;if g4.apoapsis==nil then g4.apoapsis={}g4.apoapsis.altitude=coreAltitude;g4.apoapsis.speed=0 end;if velMag<1 then g4.apoapsis.altitude=coreAltitude;g4.apoapsis.speed=0 end;if g4.apoapsis.altitude then g2=(g4.apoapsis.altitude+g4.periapsis.altitude+planet.radius*2)/(g0*2)g1=(planet.radius+g4.apoapsis.altitude)/g2*(1-g4.eccentricity)g3=g0-g4.periapsis.altitude/g2-planet.radius/g2;local gh=math.pi;if g4.period~=nil and g4.period>0 and g4.timeToApoapsis~=nil then gh=g4.eccentricAnomaly;if g4.timeToPeriapsis<g4.timeToApoapsis then gh=2*math.pi-gh end end;if velMag<1 or gh~=gh then gh=math.pi end;local gi=-g0*math.cos(gh)+fW+gc+fZ;local gj=g1*math.sin(gh)+fX+gb+fZ;local gk=""eH[#eH+1]='<g clip-path="url(#orbitRect)">'eH[#eH+1]=n([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f"/>]],gk,fW+fY+fZ,fX+fY*1.5/2+fZ,g0,g1)if g1<1 then eH[#eH+1]=n([[<line x1="%f" y1="%f" x2="%f" y2="%f" stroke="red"/>]],fW+fY+fZ-g3,fX+fY*1.5/2+fZ,gi,gj)end;eH[#eH+1]=n('<circle cx="%f" cy="%f" r="%f" stroke="white" stroke-width="1" fill="rgb(0,150,200)" opacity="0.5" />',fW+fY+fZ-g3,fX+fY*1.5/2+fZ,(planet.radius+planet.noAtmosphericDensityAltitude)/g2)eH[#eH+1]=n('<clipPath id="planetClip"><circle cx="%f" cy="%f" r="%f" /></clipPath>',fW+fY+fZ-g3,fX+fY*1.5/2+fZ,(planet.radius+planet.noAtmosphericDensityAltitude)/g2)eH[#eH+1]=n([[<ellipse class="%s line" cx="%f" cy="%f" rx="%f" ry="%f" clip-path="url(#planetClip)"/>]],"redout",fW+fY+fZ,fX+fY*1.5/2+fZ,g0,g1)eH[#eH+1]=n('<circle cx="%f" cy="%f" r="%f" stroke="black" stroke-width="1" fill="rgb(0,100,150)" />',fW+fY+fZ-g3,fX+fY*1.5/2+fZ,planet.radius/g2)eH[#eH+1]='</g>'local gl=math.floor(planet.radius/g2+0.5)d4=fW+fY+fZ*4+g0;d5=fX+fY*1.5/2+5+fZ;if g4.apoapsis~=nil and g4.apoapsis.speed<adjMaxGameVelocity then g5("Apoapsis")end;d5=fX+fY*1.5/2+5+fZ;d4=fW+fY-fZ*2-g0;if g4.periapsis~=nil and g4.periapsis.speed<adjMaxGameVelocity and g4.periapsis.altitude>0 then g5("Periapsis")end;eH[#eH+1]=cb(fW+fY+fZ,fX+20+fZ,planet.name,"txtorbbig")eH[#eH+1]=n('<circle cx="%f" cy="%f" r="2" stroke="black" stroke-width="1" fill="white" />',gi,gj)eH[#eH+1]=[[</g>]]return eH else eH[#eH+1]='<g clip-path="url(#orbitRect)">'local gm=""local gn=1.2*(maxAtlasX-minAtlasX)/(fY*2)local go=1.4*(maxAtlasY-minAtlasY)/(fY*1.5)for N,A in pairs(l[0])do if A.center then local d4=fW+fY+A.center.x/gn;local d5=fX+fY*1.5/2+A.center.y/go;gm=gm..'<circle cx="'..d4 ..'" cy="'..d5 ..'" r="'..A.radius/gn*30 ..'" stroke="white" stroke-width="1" fill="blue" />'if not string.match(A.name,"Moon")and not string.match(A.name,"Sanctuary")and not string.match(A.name,"Space")then gm=gm.."<text x='"..d4 .."' y='"..d5+A.radius/gn*30+20 .."' font-size='12' fill="..eq.." text-anchor='middle' font-family='Montserrat'>"..A.name.."</text>"end end end;local bg=vec3(j.getWorldPosition())local d4=fW+fY+bg.x/gn;local d5=fX+fY*1.5/2+bg.y/go;gm=gm..'<circle cx="'..d4 ..'" cy="'..d5 ..'" r="2" stroke="white" stroke-width="1" fill="red"/>'gm=gm.."<text x='"..d4 .."' y='"..d5-10 .."' font-size='14' fill='darkred' text-anchor='middle' font-family='Bank' font-weight='bold'>You Are Here</text>"ed=gn;ee=go;local gp=bg+constructVelocity*1000000;local gq=fW+fY+gp.x/gn;local ft=fX+fY*1.5/2+gp.y/go;gm=gm..'<line x1="'..d4 ..'" y1="'..d5 ..'" x2="'..gq..'" y2="'..ft..'" stroke="purple" stroke-width="1"/>'eH[#eH+1]=gm;eH[#eH+1]='</g>'end elseif SelectedTab=="INFO"then eH[#eH+1]=ey elseif SelectedTab=="SCOPE"then eH[#eH+1]='<g clip-path="url(#orbitRect)">'local gr=scopeFOV;local gs=vec3(DUSystem.getCameraWorldPos())local gt=vec3(DUSystem.getCameraWorldRight())local gu=vec3(DUSystem.getCameraWorldForward())if e1()then gs=worldPos;gt=constructRight;gu=constructForward end;if atmosDensity>0 then table.sort(planetAtlas,function(ax,ay)local az,aA=ax.center,ay.center;return(az.x-gs.x)^2+(az.y-gs.y)^2+(az.z-gs.z)^2<(aA.x-gs.x)^2+(aA.y-gs.y)^2+(aA.z-gs.z)^2 end)end;local gv={}local gw={}local gx=120;local gy=nil;local gz=nil;for i,A in ipairs(planetAtlas)do local cj=A.center-gs;local gA=cj:len()local gB=cj:normalize()local gC=cj:cross(gu):normalize()local gD=math.acos(gC:dot(gt))if gD~=gD then gD=0 end;if gC:cross(gt):dot(gu)<0 then gD=-gD end;local gE=cj:project_on_plane(gu):len()local gF=math.sin(gD)*math.asin(gE/gA)*constants.rad2deg;local gG=math.cos(gD)*math.asin(gE/gA)*constants.rad2deg;if gB:dot(gu)<0 then gG=90*math.cos(gD)+90*math.cos(gD)-gG;gF=90*math.sin(gD)+90*math.sin(gD)-gF end;local d4=gd+gF/gr*g9;local d5=ge+gG/gr*g9;local gH=(d4-gd)*(d4-gd)+(d5-ge)*(d5-ge)local gI=math.asin((A.radius+A.surfaceMaxAltitude)/gA)*constants.rad2deg;if gI~=gI then gI=gr end;local dq=gI/gr*g9;local gJ=math.asin(A.atmosphereRadius/gA)*constants.rad2deg;if gJ~=gJ then gJ=gI end;local gK=gJ/gr*g9;local distance=e4(gA,1)local gL=A.name;local gM=false;if d5>fX then if d5>gg then if d5-gK<=gg then gM=true end else gM=true end else if d5+gK>=fX then gM=true end end;local gN=false;local gO=d4;if A.systemId==0 then gO=d4+gx else gO=d4-gx end;if gO+gx>fW then if gO+gx>gf then if gO-gK-gx<=gf then gN=true end else gN=true end else if gO+gK+gx>=fW then gN=true end end;local gP={}gP.x=d4;gP.y=d5;gP.planet=A;gP.atmoSize=gK;if not gy or gH<gy then gy=gH;gz=gP end;if gN and gM then local gQ=math.max(gK,5)if gH<gQ*gQ then gL=gL.." - "..distance end;gP.size=dq;gP.i=i;gP.displayString=gL;gP.distance=distance;gP.visible=true;gw[#gw+1]=gP else gP.visible=false end end;local gR=false;table.sort(gw,function(az,aA)return az.y<aA.y end)for N,bd in ipairs(gw)do local A,dq,i,gK,d4,d5,gL,distance=bd.planet,bd.size,bd.i,bd.atmoSize,bd.x,bd.y,bd.displayString,bd.distance;local g7,gS,gT,gU;local gV=15;local eY="pdim"if A.systemId~=0 then gT=eB(string.len(gL)*5)gV=-(15+gT)gU=eC(10)eY="pdimfill"else gT=eB(string.len(gL)*9)gU=eC(15)end;if dq*2>gT then g7=o(d4,fW+gT/2,gf-gT/2)gS=o(d5,fX+gU,gg-5)g7=o(g7,d4-dq+gT/2,d4+dq-gT/2)gS=o(gS,d5-dq+gU,d5+dq)else g7=d4+gV;gS=d5 end;for gW,bd in pairs(gv)do local gX=bd.textPositions;local gY=gX.y-gS;if gW~=i and aV(gY)<gX.height and gX.x+gX.width>g7 and gX.x<g7+gT then if dq>gT then gS=o(gS+gU,fX+15,gg-5)else gS=gX.y+gX.height+1 end end end;local gZ=gL~=A.name or g7<=gd and g7+gT>=gd and gS-gU<=ge and gS>=ge;bd.hovered=gZ;local g_=1;if gZ then g_=2;if dq*2<gT then g_=10 end;if gL==A.name then gL=gL.." - "..distance end;eY="pbright"if A.systemId~=0 then gT=eB(string.len(gL)*5)gV=-(15+gT)else gT=eB(string.len(gL)*7)end;if dq*2>gT then g7=o(d4,fW+gT/2,gf-gT/2)g7=o(g7,d4-dq+gT/2,d4+dq-gT/2)else g7=d4+gV end end;gv[i]={}gv[i].textPositions={}gv[i].textPositions.y=gS;gv[i].textPositions.x=g7;gv[i].textPositions.width=gT;gv[i].textPositions.height=gU;gv[i].output=""if dq*2>gT then eY=eY.." txtmid"else eY=eY.." txtstart"end;if gK-dq>2 then gv[i].output=n('<circle cx="%f" cy="%f" r="%f" stroke-width="1" stroke="%s" stroke-opacity="%f" fill="url(#RadialAtmo)" />',d4,d5,gK,er,0.1*g_)end;gv[i].output=gv[i].output..n('<circle cx="%f" cy="%f" r="%f" stroke="%s" stroke-width="1" stroke-opacity="%f" fill="url(#RadialPlanetCenter)" />',d4,d5,dq,er,0.2*g_)if A.systemId==0 then gv[i].output=gv[i].output..n([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],g7,gS,eq,eY,gL)if dq*2<=gT then gv[i].output=gv[i].output..n("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",g7+gT,gS+2,g7,gS+2,d4,d5)end else gv[i].output=gv[i].output..n([[<text x='%f' y='%f'
                                            font-size='8' fill='%s' class='%s' font-family='Montserrat'>%s</text>]],g7,gS,er,eY,gL)if dq*2<=gT then gv[i].output=gv[i].output..n("<path class='linethin dimstroke' d='M %f %f L %f %f L %f %f' />",g7,gS+2,g7+gT,gS+2,d4,d5)end end end;for N=#planetAtlas,1,-1 do if gv[N]then eH[#eH+1]=gv[N].output end end;if gz~=nil and scopeFOV<90 and not gz.hovered then local h0=gz.planet.atmosphereRadius/gz.atmoSize;local h1=r(gy)*h0;local h2=e4(h1,1)local gT=eB(math.max(string.len(h2)*7,string.len(gz.planet.name)*7))local gU=eC(12)local g7=o(gz.x+(gd-gz.x)/2,fW+gT/2,gf-gT/2)local gS=o(gz.y+(ge-gz.y)/2,fX+gU*2,gg-5)eH[#eH+1]=n("<path class='linethin dimstroke' stroke='white' d='M %f %f L %f %f' />",gz.x,gz.y,gd,ge)eH[#eH+1]=n([[<text x='%f' y='%f'
                                        font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],g7,gS,"white",h2)if not gz.visible then eH[#eH+1]=n([[<text x='%f' y='%f'
                                            font-size='12' fill='%s' class='txtmid' font-family='Montserrat'>%s</text>]],g7,gS-gU,"white",gz.planet.name)end end;if velMag>1 then local cj=constructVelocity;local gB=cj:normalize()local gE=cj:project_on_plane(gu):len()local gC=cj:cross(gu):normalize()local gD=math.acos(gC:dot(gt))if gD~=gD then gD=0 end;if gC:cross(gt):dot(gu)<0 then gD=-gD end;local gF=math.sin(gD)*math.asin(gE/cj:len())*constants.rad2deg;local gG=math.cos(gD)*math.asin(gE/cj:len())*constants.rad2deg;if gB:dot(gu)<0 then gG=90*math.cos(gD)+90*math.cos(gD)-gG;gF=90*math.sin(gD)+90*math.sin(gD)-gF end;local d4=gd+gF/gr*g9;local d5=ge+gG/gr*g9;local ff=14;local fg=ff/2;local fj=[[<circle
                                    cx="]]..d4 ..[["
                                    cy="]]..d5 ..[["
                                    r="]]..fg/ff..[["
                                    style="fill:#d7fe00;stroke:none;fill-opacity:1"/>
                                <circle
                                    cx="]]..d4 ..[["
                                    cy="]]..d5 ..[["
                                    r="]]..fg..[["
                                    style="stroke:#d7fe00;stroke-opacity:1;fill:none" />
                                <path
                                    d="M ]]..d4-ff..[[,]]..d5 ..[[ h ]]..fg..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..d4+fg..[[,]]..d5 ..[[ h ]]..fg..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />
                                <path
                                    d="M ]]..d4 ..[[,]]..d5-ff..[[ v ]]..fg..[["
                                    style="stroke:#d7fe00;stroke-opacity:1" />]]eH[#eH+1]=fj end;eH[#eH+1]=n("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",gd,ge-10,gd,ge+10)eH[#eH+1]=n("<line class='linethin dimstroke' x1='%f' y1='%f' x2='%f' y2='%f' />",gd-10,ge,gd+10,ge)eH[#eH+1]='</g>'else return eH end end;local function h3(d4,d5,h4,h5,fu)local h6={x=d4,y=d5,width=h4,height=h5,label=fu}ec[fu]=h6;return h6 end;local function h7(h8,h9,h4,h5,d4,d5,ha,hb,hc,hd,eY)local h6={enableName=h8,disableName=h9,width=h4,height=h5,x=d4,y=d5,toggleVar=ha,toggleFunction=hb,drawCondition=hc,hovered=false,class=eY}if hd then table.insert(eb,h6)else table.insert(ea,h6)end;return h6 end;local function he(hf)if not eg then showHandlingVariables=false;showHudVariables=false;showPhysicsVariables=false;showHud=true;return elseif hf=="handling"then showHandlingVariables=not showHandlingVariables;showHudVariables=false;showPhysicsVariables=false elseif hf=="hud"then showHudVariables=not showHudVariables;showHandlingVariables=false;showPhysicsVariables=false elseif hf=="physics"then showPhysicsVariables=not showPhysicsVariables;showHandlingVariables=false;showHudVariables=false end;if showPhysicsVariables or showHudVariables or showHandlingVariables then eh=e3(hf)showHud=false else eh="none"showHud=true end end;local function hg()eg=not eg;if eg then e9=eb;k("Tap LMB to see Settings")oldShowHud=showHud else e9=ea;k("Tap LMB to see Control Buttons")he()showHud=oldShowHud end end;local function hh()local function hi(A,N)A.set(not A.get())if A.get()then k(N.." set to true")else k(N.." set to false")end;if N=="showHud"then oldShowHud=A.get()elseif N=="BrakeToggleDefault"then BrakeToggleStatus=BrakeToggleDefault end end;local hj=50;local hk=340;local d4=ResolutionX/2-530;local d5=ResolutionY/2-330+hj/2;local hl=0;for N,A in pairs(e3("boolean"))do if type(A.get())=="boolean"then h7(N,N,hk,hj,d4,d5,function()return A.get()end,function()hi(A,N)end,function()return true end,true)d5=d5+hj+20;if hl==9 then d4=d4+hk+20;d5=ResolutionY/2-330+hj/2;hl=0 else if d4>ResolutionX/2-hk and d4<ResolutionX/2+hk/2 and d5>ResolutionY/2-hj and d5<ResolutionY/2+hj then d5=d5+hj+20;hl=hl+1 end;hl=hl+1 end end end;h7("Control View","Control View",hk,hj,10,ResolutionY/2-500,function()return true end,hg,function()return true end,true)h7("View Handling Settings",'Hide Handling Settings',hk,hj,10,ResolutionY/2-(500-hj),function()return showHandlingVariables end,function()he("handling")end,function()return true end,true)h7("View Hud Settings",'Hide Hud Settings',hk,hj,10,ResolutionY/2-(500-hj*2),function()return showHudVariables end,function()he("hud")end,function()return true end,true)h7("View Physics Settings",'Hide Physics Settings',hk,hj,10,ResolutionY/2-(500-hj*3),function()return showPhysicsVariables end,function()he("physics")end,function()return true end,true)end;local function hm()local function bX()local position=worldPos;local bY=planet.name..". "..#SavedLocations;if RADAR then bY=RADAR.GetClosestName(bY)end;return ATLAS.AddNewLocation(bY,position,false,true)end;local function hn()TurnBurn=not TurnBurn end;local function ho(hp)if hp==1 then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false end;Autopilot=false;AltitudeHold=false;followMode=false;BrakeLanding=false;LockPitch=nil;Reentry=false;AutoTakeoff=false end;local function hq(hr,hs)ATLAS.UpdatePosition(nil,hr,hs)end;local function bT()ATLAS.ClearCurrentPosition()end;local function ht(bW)local fU=AP.routeWP(true)if fU and#fU>0 then return"Engage Route: "..fU[1]end;return"Engage Autopilot: "..fS(bW)end;local function hu(bW)local fU=AP.routeWP(true)if fU and#fU>0 then return"Next Route Point: "..fU[1]end;return"Disable Autopilot: "..fS(bW)end;local function hv()if d_()then followMode=not followMode;if followMode then Autopilot=false;RetrogradeIsOn=false;ProgradeIsOn=false;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;OldGearExtended=GearExtended;GearExtended=false;d.control.retractLandingGears()e0:setTargetGroundAltitude(TargetHoverHeight)bE("folOn","F")else bE("folOff","F")BrakeIsOn="Follow Off"autoRoll=autoRollPreference;GearExtended=OldGearExtended;if GearExtended then d.control.deployLandingGears()e0:setTargetGroundAltitude(LandingGearGroundHeight)end end else k("Follow Mode only works with Remote controller")followMode=false end end;local hj=50;local hk=260;local hw=eB(30)local hx=OrbitMapX+OrbitMapSize*2+2;local hy=OrbitMapY+1;h7("+","+",hw,hw,hx,hy+hw+1,function()return false end,function()scopeFOV=scopeFOV/8 end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")h7("-","-",hw,hw,hx,hy,function()return false end,function()scopeFOV=math.min(scopeFOV*8,90)end,function()return SelectedTab=="SCOPE"end,nil,"ZoomButton")h7("0","0",hw,hw,hx,hy+hw*2+2,function()return false end,function()scopeFOV=90 end,function()return SelectedTab=="SCOPE"and scopeFOV~=90 end,nil,"ZoomButton")local hz=h7("Enable Brake Toggle","Disable Brake Toggle",hk,hj,ResolutionX/2-hk/2,ResolutionY/2+350,function()return BrakeToggleStatus end,function()BrakeToggleStatus=not BrakeToggleStatus;if BrakeToggleStatus then k("Brakes in Toggle Mode")else k("Brakes in Default Mode")end end)h7("Align Prograde","Disable Prograde",hk,hj,ResolutionX/2-hk/2-50-hz.width,ResolutionY/2-hj+380,function()return ProgradeIsOn end,function()ho(1)end)h7("Align Retrograde","Disable Retrograde",hk,hj,ResolutionX/2-hk/2+hz.width+50,ResolutionY/2-hj+380,function()return RetrogradeIsOn end,ho,function()return atmosDensity==0 end)apbutton=h7(ht,hu,600,60,ResolutionX/2-600/2,ResolutionY/2-60/2-330,function()return Autopilot or VectorToTarget or spaceLaunch or IntoOrbit end,function()end)local i;local function hA(hB)local bW=apScrollIndex+hB;if bW>#AtlasOrdered then bW=bW-#AtlasOrdered-1 end;if bW<0 then bW=#AtlasOrdered+bW end;return bW end;apExtraButtons={}for i=0,10 do local button=h7(function(aA)local bW=hA(aA.apExtraIndex)if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then return"Redirect: "..fS(bW)end;return ht(bW)end,function(aA)local bW=hA(aA.apExtraIndex)return hu(bW)end,600,60,ResolutionX/2-600/2,ResolutionY/2-60/2-330+60*i,function(aA)local bW=hA(aA.apExtraIndex)return bW==AutopilotTargetIndex and(Autopilot or VectorToTarget or spaceLaunch or IntoOrbit)end,function(aA)local bW=hA(aA.apExtraIndex)local hC=AutopilotTargetIndex==bW;AutopilotTargetIndex=bW;ATLAS.UpdateAutopilotTarget()AP.ToggleAutopilot()if not hC and not(Autopilot or VectorToTarget or spaceLaunch or IntoOrbit)then AP.ToggleAutopilot()end end,function()return apButtonsHovered and(#AP.routeWP(true)==0 or i==0)end)button.apExtraIndex=i;apExtraButtons[i]=button end;h7("Save Position","Save Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,bX,function()return AutopilotTargetIndex==0 or CustomTarget==nil end)h7("Update Position","Update Position",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y,function()return false end,function()hq(nil)end,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)h7("Save Heading","Clear Heading",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y+apbutton.height+20,function()return CustomTarget.heading~=nil end,function()if CustomTarget.heading~=nil then hq(false)else hq(true)end end,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)h7("Save AGG Alt","Clear AGG Alt",200,apbutton.height,apbutton.x+apbutton.width+30,apbutton.y+apbutton.height*2+40,function()return CustomTarget.agg~=nil end,function()if CustomTarget.agg~=nil then hq(nil,false)else hq(nil,true)end end,function()return AutopilotTargetIndex>0 and CustomTarget~=nil and antigrav end)h7("Clear Position","Clear Position",200,apbutton.height,apbutton.x-200-30,apbutton.y,function()return true end,bT,function()return AutopilotTargetIndex>0 and CustomTarget~=nil end)h7("Save Route","Save Route",200,apbutton.height,apbutton.x-200-30,apbutton.y+apbutton.height*2+40,function()return false end,function()AP.routeWP(false,false,2)end,function()return#AP.routeWP(true)>0 end)h7("Load Route","Clear Route",200,apbutton.height,apbutton.x-200-30,apbutton.y+apbutton.height+20,function()return#AP.routeWP(true)>0 end,function()if#AP.routeWP(true)>0 then AP.routeWP(false,true)elseif Autopilot or VectorToTarget then k("Disable Autopilot before loading route")return else AP.routeWP(false,false,1)end end,function()return true end)hj=60;hk=300;local d4=0;local d5=ResolutionY/2-150;h7("Enable Check Damage","Disable Check Damage",hk,hj,d4,d5-hj-20,function()return ShouldCheckDamage end,function()ShouldCheckDamage=not ShouldCheckDamage end)h7("View Settings","View Settings",hk,hj,d4,d5,function()return true end,hg)d5=d5+hj+20;h7("Enable Turn and Burn","Disable Turn and Burn",hk,hj,d4,d5,function()return TurnBurn end,hn)d4=10;d5=ResolutionY/2-300;h7("Horizontal Takeoff Mode","Vertical Takeoff Mode",hk,hj,ResolutionX/2-hk/2,d5+20,function()return VertTakeOffEngine end,function()VertTakeOffEngine=not VertTakeOffEngine;if VertTakeOffEngine then k("Vertical Takeoff Mode")else k("Horizontal Takeoff Mode")end end,function()return UpVertAtmoEngine end)d5=d5+hj+20;h7("Engage Orbiting","Cancel Orbiting",hk,hj,d4+hk+20,d5,function()return IntoOrbit end,AP.ToggleIntoOrbit,function()return atmosDensity==0 and nearPlanet end)d5=ResolutionY/2-150;h7("Glide Re-Entry","Cancel Glide Re-Entry",hk,hj,d4+hk+20,d5,function()return Reentry end,function()spaceLand=1;ho(1)end,function()return planet.hasAtmosphere and not inAtmo end)d5=d5+hj+20;h7("Parachute Re-Entry","Cancel Parachute Re-Entry",hk,hj,d4+hk+20,d5,function()return Reentry end,function()spaceLand=2;ho(1)end,function()return planet.hasAtmosphere and not inAtmo end)d5=d5+hj+20;h7("Engage Follow Mode","Disable Follow Mode",hk,hj,d4,d5,function()return followMode end,hv,function()return d_()end)h7("Enable Repair Arrows","Disable Repair Arrows",hk,hj,d4+hk+20,d5,function()return ew end,function()ew=not ew;if ew then k("Repair Arrows Enabled")else k("Repair Arrows Diabled")end end,function()return d_()end)d5=d5+hj+20;if not ExternalAGG then h7("Enable AGG","Disable AGG",hk,hj,d4,d5,function()return antigravOn end,AP.ToggleAntigrav,function()return antigrav~=nil end)end;h7(function()return n("Switch IPH Mode - Current: %s",iphCondition)end,function()return n("IPH Mode: %s",iphCondition)end,hk*2,hj,d4,d5,function()return false end,function()if iphCondition=="All"then iphCondition="Custom Only"elseif iphCondition=="Custom Only"then iphCondition="No Moons-Asteroids"else iphCondition="All"end;k("IPH Mode: "..iphCondition)end)d5=d5+hj+20;h7(function()return n("Toggle Control Scheme - Current: %s",userControlScheme)end,function()return n("Control Scheme: %s",userControlScheme)end,hk*2,hj,d4,d5,function()return false end,function()if userControlScheme=="keyboard"then userControlScheme="mouse"elseif userControlScheme=="mouse"then userControlScheme="virtual joystick"else userControlScheme="keyboard"end;k("New Control Scheme: "..userControlScheme)end)local hD=eC(20)local button=h3(0,0,eB(80),hD,"INFO")button=h3(button.x+button.width,button.y,eB(70),hD,"ORBIT")button=h3(button.x+button.width,button.y,eB(70),hD,"SCOPE")h3(button.x+button.width,button.y,eB(70),hD,"HIDE")end;local function hE(eH,fL)if fL~="empty"then local d5=310;for fN in string.gmatch(fL,"([^\n]+)")do d5=d5+35;eH[#eH+1]=cb("50%",d5,fN,"msg")end end;if msgTimer~=0 then c.setTimer("msgTick",msgTimer)msgTimer=0 end end;local hF={}local hG=nil;local function hH(eH)local f5=adjustedPitch;local hI=adjustedRoll;local hJ=hI;local hK=f5;local fq=g(c.getThrottle())local fx=velMag*3.6;local fr=c.getAxisCommandValue(0)local function hL(eH,hK,hJ,centerX,centerY,nearPlanet,hM,f9)if circleRad==0 then return end;local fa=circleRad;local hN=g(fa*3/5)if fa>0 then local hO=g(hK)local len=0;local hP=n([[<path transform="rotate(%f,%d,%d)" class="dim line" d="]],-1*hJ,centerX,centerY)if not inAtmo then hP=n([[<path transform="rotate(0,%d,%d)" class="dim line" d="]],centerX,centerY)end;eH[#eH+1]=n([[<clipPath id="cut"><circle r="%f" cx="%d" cy="%d"/></clipPath>]],fa-1,centerX,centerY)eH[#eH+1]=[[<g class="dim txttick" clip-path="url(#cut)">]]for i=g(hO-30-hO%5+0.5),g(hO+30+hO%5+0.5),5 do if i%10==0 then len=30 elseif i%5==0 then len=20 end;local d5=centerY+-i*5+hK*5;if len==30 then hP=n([[%s M %d %f h %d]],hP,centerX-hN-len,d5,len)if inAtmo then eH[#eH+1]=n([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hJ,centerX,centerY,centerX-hN+10,d5+4,i)eH[#eH+1]=n([[<g path transform="rotate(%f,%d,%d)" class="pdim txt txtmid"><text x="%d" y="%f">%d</text></g>]],-1*hJ,centerX,centerY,centerX+hN-10,d5+4,i)if i==0 or i==180 or i==-180 then eH[#eH+1]=n([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hJ,centerX,centerY,centerX-hN+20,d5,hN*2-40)end else eH[#eH+1]=cb(centerX-hN+10,d5,i,"pdim txt txtmid")eH[#eH+1]=cb(centerX+hN-10,d5,i,"pdim txt txtmid")end;hP=n([[%s M %d %f h %d]],hP,centerX+hN,d5,len)else hP=n([[%s M %d %f h %d]],hP,centerX-hN-len,d5,len)hP=n([[%s M %d %f h %d]],hP,centerX+hN,d5,len)end end;eH[#eH+1]=hP..[["/>]]local hQ="PITCH"if not nearPlanet then hQ="REL PITCH"end;if hK>90 and not inAtmo then hK=90-(hK-90)elseif hK<-90 and not inAtmo then hK=-90-(hK+90)end;if fa>200 then if inAtmo then if f9>ej then eH[#eH+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")eH[#eH+1]=cb(centerX,centerY+20,hM,"pdim txt txtmid")end;eH[#eH+1]=n([[<g transform="rotate(%f,%d,%d)">]],-hJ,centerX,centerY)else eH[#eH+1]=n([[<g transform="rotate(0,%d,%d)">]],centerX,centerY)end;eH[#eH+1]=n([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX-hN+25,centerY-5,centerX-hN+20,centerY,centerX-hN+25,centerY+5,centerX-hN+50,centerY+4,hO)eH[#eH+1]=n([[<<polygon points="%d,%d %d,%d %d,%d"/> class="pdim txtend"><text x="%d" y="%f">%d</text>]],centerX+hN-25,centerY-5,centerX+hN-20,centerY,centerX+hN-25,centerY+5,centerX+hN-30,centerY+4,hO)eH[#eH+1]="</g>"end;local hR=g(fa/3)eH[#eH+1]=n([[<path d="m %d,%d %d,0" stroke-width="2" style="fill:none;stroke:#F5B800;" />]],centerX-hR,centerY,fa-hR)if not inAtmo and nearPlanet then eH[#eH+1]=n([[<path transform="rotate(%f,%d,%d)" d="m %d,%f %d,0" stroke-width="1" style="fill:none;stroke:#F5B800;" />]],-1*hJ,centerX,centerY,centerX-hN+10,centerY,hN*2-20)end;eH[#eH+1]="</g>"if fa<200 then if inAtmo and f9>ej then eH[#eH+1]=cb(centerX,centerY-fa,hQ,"pdim txt txtmid")eH[#eH+1]=cb(centerX,centerY-fa+10,hO,"pdim txt txtmid")eH[#eH+1]=cb(centerX,centerY-15,"Yaw","pdim txt txtmid")eH[#eH+1]=cb(centerX,centerY+20,hM,"pdim txt txtmid")else eH[#eH+1]=cb(centerX,centerY-fa,hQ,"pdim txt txtmid")eH[#eH+1]=cb(centerX,centerY-fa+15,hO,"pdim txt txtmid")end end end end;local function hS(eH,centerX,centerY,hJ,hT,nearPlanet)local function hU(hV)local bS=-worldVertical;hV=hV-hV:project_on(bS)local hW=vec3(0,0,1)hW=hW-hW:project_on(bS)local hX=hW:cross(bS)local eI=hW:angle_between(hV)*constants.rad2deg;if hV:dot(hX)<0 then eI=360-eI end;return eI end;if circleRad==0 then return end;local fa=circleRad;local hY=20;local hZ=g(hJ)if nearPlanet then for i=-45,45,5 do local h_=i;eH[#eH+1]=n([[<g transform="rotate(%f,%d,%d)">]],h_,centerX,centerY)len=5;if i%15==0 then len=15 elseif i%10==0 then len=10 end;eH[#eH+1]=n([[<line x1=%d y1=%d x2=%d y2="%d"/></g>]],centerX,centerY+fa+hY-len,centerX,centerY+fa+hY)end;eH[#eH+1]=cb(centerX,centerY+fa+hY-35,hT,"pdim txt txtmid")eH[#eH+1]=cb(centerX,centerY+fa+hY-25,hZ.." deg","pdim txt txtmid")eH[#eH+1]=n([[<g transform="rotate(%f,%d,%d)">]],-hJ,centerX,centerY)eH[#eH+1]=n([[<<polygon points="%d,%d %d,%d %d,%d"/>]],centerX-5,centerY+fa+hY-20,centerX+5,centerY+fa+hY-20,centerX,centerY+fa+hY-15)eH[#eH+1]="</g>"end;eH[#eH+1]=[[<g style="clip-path: url(#headingClip);">]]local f7=hZ;if nearPlanet then f7=hU(constructForward)end;local i0=20;local i1=g(f7)local i2=0;local i3=centerY+fa+hY+20;local i4=centerX;if hT~="YAW"then i3=eC(130)i4=eB(960)end;local hP=[[<path class="txttick line" d="]]local i5=g(i1-(i0+10)-i1%5+0.5)for i=i5+70,i5,-5 do local d4=i4-(-i*5+f7*5)if i%10==0 then i2=10;local F=i;if F==360 then F=0 elseif F>360 then F=F-360 elseif F<0 then F=F+360 end;eH[#eH+1]=cb(d4,i3+15,F,"txtmid bright")elseif i%5==0 then i2=5 end;if i2==10 then hP=n([[%s M %f %f v %d]],hP,d4,i3-5,i2)else hP=n([[%s M %f %f v %d]],hP,d4,i3-2.5,i2)end end;eH[#eH+1]=hP..[["/>]]eH[#eH+1]=n([[<<polygon class="bright" points="%d,%d %d,%d %d,%d"/>]],i4-5,i3-20,i4+5,i3-20,i4,i3-10)if nearPlanet then hT="HDG"end;eH[#eH+1]=cb(eB(960),eC(100),i1 .."°","dim txt txtmid size14","")eH[#eH+1]=cb(eB(960),eC(85),hT,"dim txt txtmid size20","")eH[#eH+1]=[[</g>]]end;if AtmoSpeedAssist and throttleMode then fr=PlayerThrottle;fq=PlayerThrottle*100 end;local hT="ROLL"if fq==nil then fq=0 end;if not nearPlanet then if velMag>5 then f5=f4(coreVelocity)hI=f6(coreVelocity)else f5=0;hI=0 end;hT="YAW"end;eH[#eH+1]=eu;eH[#eH+1]=dE;if ei~=""then eH[#eH+1]=ei end;if eE~=""then eH[#eH+1]=eE end;if eF~=""then eH[#eH+1]=eF end;eG(eH,coreAltitude)if not d_()or RemoteHud then if not eD()or brightHud then if nearPlanet then hS(eH,centerX,centerY,hJ,hT,nearPlanet)hL(eH,hK,hJ,centerX,centerY,nearPlanet,g(f6(coreVelocity)),velMag)else hS(eH,centerX,centerY,hI,hT,nearPlanet)hL(eH,f5,hI,centerX,centerY,nearPlanet,g(hI),velMag)end;eJ(eH,coreAltitude,nearPlanet)f8(eH,coreVelocity,velMag,centerX,centerY)end end;fp(eH,eA,fq,fr)fw(eH,fx)fB(eH)fV(eH)if not eg and holdingShift then fT(eH)end;return eH end;local i6=0;local i7=0;local i8=0;local i9=0;function hF.DisplayOrbitScreen(eH)return fV(eH)end;function hF.hudtick()if not planet then return end;local function ia(eH)local ib=g(o(mouseDistance/(ResolutionX/4)*255,0,255))eH[#eH+1]=n("<line x1='0' y1='0' x2='%fpx' y2='%fpx' style='stroke:rgb(%d,%d,%d);stroke-width:2;transform:translate(50%%, 50%%)' />",simulatedX,simulatedY,g(en+0.5)+ib,g(eo+0.5)-ib,g(ep+0.5)-ib)end;local function ic()if leftmouseclick then for _,A in pairs(e9)do if A.hovered then if not A.drawCondition or A.drawCondition(A)then A.toggleFunction(A)end;A.hovered=false end end;for _,A in pairs(ec)do if A.hovered then SelectedTab=A.label;A.hovered=false end end;leftmouseclick=false end end;local function id()local function ie(ig,ih,d4,d5,h4,h5)if ig>=d4 and ig<=d4+h4 and ih>=d5 and ih<=d5+h5 then return true else return false end end;local d4=simulatedX+ResolutionX/2;local d5=simulatedY+ResolutionY/2;for _,A in pairs(e9)do A.hovered=ie(d4,d5,A.x,A.y,A.width,A.height)end;for _,A in pairs(ec)do A.hovered=ie(d4,d5,A.x,A.y,A.width,A.height)end;if apButtonsHovered then local gZ=false;for _,aA in ipairs(apExtraButtons)do if aA.hovered then gZ=true;break end end;if apbutton.hovered then gZ=true end;apButtonsHovered=gZ else apButtonsHovered=apbutton.hovered;if not apButtonsHovered then apScrollIndex=AutopilotTargetIndex end end end;local function ii(eH)local function ij(eH,ik,hover,d4,d5,il,im,io,ip,iq,ir,button)if type(iq)=="function"then iq=iq(button)end;if type(ir)=="function"then ir=ir(button)end;eH[#eH+1]=n("<rect x='%f' y='%f' width='%f' height='%f' fill='",d4,d5,il,im)if ik then eH[#eH+1]=n("%s'",io)else eH[#eH+1]=ip end;if hover then eH[#eH+1]=n(" style='stroke:rgb(%d,%d,%d); stroke-width:2'",SafeR,SafeG,SafeB)else eH[#eH+1]=n(" style='stroke:rgb(%d,%d,%d); stroke-width:1'",bF(SafeR*0.5,0),bF(SafeG*0.5,0),bF(SafeB*0.5,0))end;eH[#eH+1]=" rx='5'></rect>"eH[#eH+1]=n("<text x='%f' y='%f' font-size='24' fill='",d4+il/2,d5+im/2+5)if ik then eH[#eH+1]="black"else eH[#eH+1]="white"end;eH[#eH+1]="' text-anchor='middle' font-family='Play' style='stroke-width:0px;'>"if ik then eH[#eH+1]=n("%s</text>",iq)else eH[#eH+1]=n("%s</text>",ir)end end;local is=n("rgb(%d,%d,%d)'",bF(SafeR*0.1,0),bF(SafeG*0.1,0),bF(SafeB*0.1,0))local it=n("rgb(%d,%d,%d)",bF(SafeR*0.8,0),bF(SafeG*0.8,0),bF(SafeB*0.8,0))local iu=ij;for _,A in pairs(e9)do local h9=A.disableName;local h8=A.enableName;if type(h9)=="function"then h9=h9(A)end;if type(h8)=="function"then h8=h8(A)end;if not A.drawCondition or A.drawCondition(A)then iu(eH,A.toggleVar(A),A.hovered,A.x,A.y,A.width,A.height,it,is,h9,h8,A)end end end;local function iv(eH)if not notPvPZone then en=PvPR;eo=PvPG;ep=PvPB else en=SafeR;eo=SafeG;ep=SafeB end;eq=[[rgb(]]..g(en+0.6)..","..g(eo+0.6)..","..g(ep+0.6)..[[)]]er=[[rgb(]]..g(en*0.8+0.5)..","..g(eo*0.8+0.5)..","..g(ep*0.8+0.5)..[[)]]local iw=eq;local ix=er;local iy=[[rgb(]]..g(en*0.4+0.5)..","..g(eo*0.4+0.5)..","..g(ep*0.4+0.5)..[[)]]local iz=eq;local iA=er;local iB=iy;if eD()and not brightHud then iw=[[rgb(]]..g(en*0.5+0.5)..","..g(eo*0.5+0.5)..","..g(ep*0.5+0.5)..[[)]]ix=[[rgb(]]..g(en*0.3+0.5)..","..g(eo*0.3+0.5)..","..g(ep*0.2+0.5)..[[)]]iy=[[rgb(]]..g(en*0.2+0.5)..","..g(eo*0.2+0.5)..","..g(ep*0.2+0.5)..[[)]]end;eH[#eH+1]=n([[ <head> <style>body{margin: 0}svg{position:absolute;top:0;left:0;font-family:Montserrat;}.txt{font-size:10px;font-weight:bold;}.txttick{font-size:12px;font-weight:bold;}.txtbig{font-size:14px;font-weight:bold;}.altsm{font-size:16px;font-weight:normal;}.altbig{font-size:21px;font-weight:normal;}.line{stroke-width:2px;fill:none;stroke:%s}.linethick{stroke-width:3px;fill:none}.linethin{stroke-width:1px;fill:none}.warnings{font-size:26px;fill:red;text-anchor:middle;font-family:Bank;}.warn{fill:orange; font-size:24px}.crit{fill:darkred;font-size:28px}.bright{fill:%s;stroke:%s}text.bright{stroke:black; stroke-width:10px;paint-order:stroke;}.pbright{fill:%s;stroke:%s}text.pbright{stroke:black; stroke-width:10px;paint-order:stroke;}.dim{fill:%s;stroke:%s}text.dim{stroke:black; stroke-width:10px;paint-order:stroke;}.pdim{fill:%s;stroke:%s}text.pdim{stroke:black; stroke-width:10px;paint-order:stroke;}.red{fill:red;stroke:red}text.red{stroke:black; stroke-width:10px;paint-order:stroke;}.orange{fill:orange;stroke:orange}text.orange{stroke:black; stroke-width:10px;paint-order:stroke;}.redout{fill:none;stroke:red}.op30{opacity:0.3}.op10{opacity:0.1}.txtstart{text-anchor:start}.txtend{text-anchor:end}.txtmid{text-anchor:middle}.txtvspd{font-family:sans-serif;font-weight:normal}.txtvspdval{font-size:20px}.txtfuel{font-size:11px;font-weight:bold}.txtorb{font-size:12px}.txtorbbig{font-size:18px}.hudver{font-size:10px;font-weight:bold;fill:red;text-anchor:end;font-family:Bank}.msg{font-size:40px;fill:red;text-anchor:middle;font-weight:normal}.cursor{stroke:white}text{stroke:black; stroke-width:10px;paint-order:stroke;}.dimstroke{stroke:%s}.brightstroke{stroke:%s}.indicatorText{font-size:20px;fill:white}.size14{font-size:14px}.size20{font-size:20px}.topButton{fill:%s;opacity:0.5;stroke-width:2;stroke:%s}.topButtonActive{fill:url(#RadialGradientCenter);opacity:0.8;stroke-width:2;stroke:%s}.topButton text{font-size:13px; fill: %s; opacity:1; stroke-width:20px}.topButtonActive text{font-size:13px;fill:%s; stroke-width:0px; opacity:1}.indicatorFont{font-size:20px;font-family:Bank}.dimmer{stroke: %s;}.pdimfill{fill: %s;}.dimfill{fill: %s;}</style> </head> <body> <svg height="100%%" width="100%%" viewBox="0 0 %d %d"> <defs> <radialGradient id="RadialGradientCenterTop" cx="0.5" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="100%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientRightTop" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinRightTopGradient" cx="1" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientLeftTop" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.5"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="ThinLeftTopGradient" cx="0" cy="0" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.2"/> <stop offset="200%%" stop-color="black" stop-opacity="0"/> </radialGradient> <radialGradient id="RadialGradientCenter" cx="0.5" cy="0.5" r="1"> <stop offset="0%%" stop-color="%s" stop-opacity="0.8"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.5"/> </radialGradient> <radialGradient id="RadialPlanetCenter" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="1"/> </radialGradient> <radialGradient id="RadialAtmo" cx="0.5" cy="0.5" r="0.5"> <stop offset="0%%" stop-color="%s" stop-opacity="1"/> <stop offset="66%%" stop-color="%s" stop-opacity="1"/> <stop offset="100%%" stop-color="%s" stop-opacity="0.1"/> </radialGradient> </defs> <g class="pdim txt txtend">]],iw,iw,iw,iz,iz,ix,ix,iA,iA,ix,iw,iy,iA,iw,iw,iy,iy,iB,iy,ResolutionX,ResolutionY,ix,ix,ix,ix,ix,iz,ix,iA,iB,iA,iA,iB)if showHud and DisplayOdometer then eH[#eH+1]=hG end;return eH end;local function iC(eH)eH[#eH+1]=n([[<circle class="dim line" style="fill:none" cx="50%%" cy="50%%" r="%d"/>]],DeadZone)end;local function iD(eH)local d4=eB(640)local d5=eC(200)eH[#eH+1]=[[<g class="pbright txtvspd txtstart">]]local dl=0;for N,A in pairs(eh)do dl=dl+1;eH[#eH+1]=cb(d4,d5,N..": "..A.get())d5=d5+20;if dl%12==0 then d4=d4+eB(350)d5=eC(200)end end;eH[#eH+1]=cb(eB(640),eC(200)+260,"To Change: In Lua Chat, enter /G VariableName Value")eH[#eH+1]="</g>"return eH end;local dD=eC(125)local dC=eB(1225)local function iE()dE=RADAR.GetRadarHud(dC,dD,radarX,radarY)if dE then cm=true end end;local iF=bF(ResolutionX/2,0)local iG=bF(ResolutionY/2,0)local eH={}if userScreen then eH[#eH+1]=userScreen end;iv(eH)if showHud then hH(eH)else if AlwaysVSpd then eG(eH,coreAltitude)end;fB(eH)end;if eg and eh~="none"then iD(eH)end;if RADAR then iE()else dE=""end;eH[#eH+1]="</svg>"eH[#eH+1]=n([[<svg width="100%%" height="100%%" style="position:absolute;top:0;left:0"  viewBox="0 0 %d %d">]],ResolutionX,ResolutionY)if msgText~="empty"then hE(eH,msgText)end;if not d_()and userControlScheme=="virtual joystick"then if DisplayDeadZone then iC(eH)end end;if not e1()then if d_()and holdingShift then if not AltIsOn then id()ii(eH)end;if not Animating and not Animated then local iH=table.concat(eH,"")eH={}eH[#eH+1]=n("<style>@keyframes test { from { opacity: 0; } to { opacity: 1; } }  body { animation-name: test; animation-duration: 0.5s; }</style><body><svg width='100%%' height='100%%' position='absolute' top='0' left='0'><rect width='100%%' height='100%%' x='0' y='0' position='absolute' style='fill:rgb(6,5,26);'/></svg><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ResolutionX,ResolutionY)eH[#eH+1]=iH;eH[#eH+1]="</body>"Animating=true;eH[#eH+1]=[[</svg></body>]]c.setTimer("animateTick",0.5)elseif Animated then local iH=table.concat(eH,"")eH={}eH[#eH+1]=n("<body style='background-color:rgb(6,5,26)'><svg width='50%%' height='50%%' style='position:absolute;top:30%%;left:25%%' viewbox='0 0 %d %d'>",ResolutionX,ResolutionY)eH[#eH+1]=iH;eH[#eH+1]="</body>"end;if not Animating then eH[#eH+1]=n([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],iF,iG,simulatedX,simulatedY)end else ic()end else if not holdingShift and not d_()then ic()if mouseDistance>DeadZone then if DisplayDeadZone then ia(eH)end end elseif holdingShift and(not AltIsOn or not freeLookToggle)then id()ii(eH)end;eH[#eH+1]=n([[<g transform="translate(%d %d)"><circle class="cursor" cx="%fpx" cy="%fpx" r="5"/></g>]],iF,iG,simulatedX,simulatedY)end;eH[#eH+1]=[[</svg></body>]]content=table.concat(eH,"")end;local iI=1;local iJ=2;local iK=3;local iL=4;local iM=5;local iN=6;local iO=7;local iP=""local iQ=0;local iR=90.0*hudTickRate;local iS={}local iT={}local iU={}local iV={}local iW={}local iX={}local iY={}iY["atmofueltank"],iY["spacefueltank"],iY["rocketfueltank"]=0,0,0;local iZ=0;local i_=1-(ContainerOptimization*0.05+FuelTankOptimization*0.05)function hF.FuelUsed(j0)local j1;if j0=="atmofueltank"then j1=n("Atmo Fuel Used: %.1f L",iY[j0]/(4*i_))elseif j0=="spacefueltank"then j1=n("Space Fuel Used: %.1f L",iY[j0]/(6*i_))else j1=n("Rocket Fuel Used: %.1f L",iY[j0]/(0.8*i_))end;return j1 end;function hF.TenthTick()local function j2()local j3=a.createData;local j4=a.createWidget;panelInterplanetary=a.createWidgetPanel("Interplanetary Helper")interplanetaryHeader=j4(panelInterplanetary,"value")interplanetaryHeaderText=j3('{"label": "Target Planet", "value": "N/A", "unit":""}')bD(interplanetaryHeaderText,interplanetaryHeader)widgetDistance=j4(panelInterplanetary,"value")widgetDistanceText=j3('{"label": "distance", "value": "N/A", "unit":""}')bD(widgetDistanceText,widgetDistance)widgetTravelTime=j4(panelInterplanetary,"value")widgetTravelTimeText=j3('{"label": "Travel Time", "value": "N/A", "unit":""}')bD(widgetTravelTimeText,widgetTravelTime)widgetTargetOrbit=j4(panelInterplanetary,"value")widgetTargetOrbitText=j3('{"label": "Target Altitude", "value": "N/A", "unit":""}')bD(widgetTargetOrbitText,widgetTargetOrbit)widgetTargetEngine=j4(panelInterplanetary,"value")widgetTargetEngineText=j3('{"label": "Space Engine", "value": "N/A", "unit":""}')bD(widgetTargetEngineText,widgetTargetEngine)widgetStopSpeed=j4(panelInterplanetary,"value")widgetStopSpeedText=j3('{"label": "End Speed", "value": "N/A", "unit":""}')widgetCurBrakeDistance=j4(panelInterplanetary,"value")widgetCurBrakeDistanceText=j3('{"label": "Cur Brake distance", "value": "N/A", "unit":""}')widgetCurBrakeTime=j4(panelInterplanetary,"value")widgetCurBrakeTimeText=j3('{"label": "Cur Brake Time", "value": "N/A", "unit":""}')widgetMaxBrakeDistance=j4(panelInterplanetary,"value")widgetMaxBrakeDistanceText=j3('{"label": "Max Brake distance", "value": "N/A", "unit":""}')widgetMaxBrakeTime=j4(panelInterplanetary,"value")widgetMaxBrakeTimeText=j3('{"label": "Max Brake Time", "value": "N/A", "unit":""}')widgetTrajectoryAltitude=j4(panelInterplanetary,"value")widgetTrajectoryAltitudeText=j3('{"label": "Projected Altitude", "value": "N/A", "unit":""}')if not inAtmo then bD(widgetStopSpeedText,widgetStopSpeed)bD(widgetCurBrakeDistanceText,widgetCurBrakeDistance)bD(widgetCurBrakeTimeText,widgetCurBrakeTime)bD(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)bD(widgetMaxBrakeTimeText,widgetMaxBrakeTime)bD(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end end;local function j5()ca(panelInterplanetary)panelInterplanetary=nil end;local function j6()local j7=GetFuelTankPrefixes;local function j8(d4,j9,ja,jb,jc,jd)local fs=iZ;local ft=iZ+5;if not BarFuelDisplay then ft=ft+5 end;if d_()and not RemoteHud then fs=fs-50;ft=ft-50 end;if ja=="ATMO"then iP="atmofueltank"elseif ja=="SPACE"then iP="spacefueltank"else iP="rocketfueltank"end;iQ=_G[iP.."_size"]if#jb>0 then for i=1,#jb do local bY=jb[i][iJ]local je=jb[i][iO]for jf=1,iQ do if jb[i][iJ]==dY(c[iP.."_"..jf].getWidgetData()).name then je=jf;break end end;local jg=f()if jc[i]==nil or jd[i]==nil or jg-jb[i][iN]>iR then local jh;local ji=0;ji=dZ(jb[i][iI])-jb[i][iL]jh=jb[i][iM]local jj=jh>ji or false;if jj then iY[iP]=iY[iP]+jh-ji end;if je~=0 then local jk=dY(c[iP.."_"..je].getWidgetData())jd[i]=jk.percentage;jc[i]=jk.timeLeft;if jc[i]=="n/a"then jc[i]=0 end else jd[i]=g(0.5+ji*100/jb[i][iK])if jj then jc[i]=g(0.5+ji/((jh-ji)/(jg-jb[i][iN])))else jc[i]=0 end end;jb[i][iN]=jg;jb[i][iM]=ji end;for _,jl in pairs(j9)do if bY==jl then bY=n("%s %d",ja,i)break end end;if je==0 then bY=bY.." *"end;local jm;jm=e5(jc[i])if jc[i]==0 or jm==">1y"then jm=""end;if jd[i]~=nil then local jn=g(jd[i]*2.55)local jo=n("rgb(%d,%d,%d)",255-jn,jn,0)local eY=""if jm~=""and jc[i]<120 or jd[i]<5 then eY="red "end;local jp=n("rgb(%d,%d,%d)",o(g((255-jn)/2.55),50,100),o(g(jn/2.55),0,50),50)local ib="rgb(196,0,255)"if ja=="ATMO"then ib="rgb(0,188,255)"elseif ja=="SPACE"then ib="rgb(239,255,0)"end;local jq=false;if previous~=ib then jq=true end;previous=ib;if BarFuelDisplay then if jq then fs=fs-5;ft=ft-5 end;eE=eE..n([[
                                                    <g class="pdim">                        
                                                    <rect fill=%s class="bar" stroke=%s x="%d" y="%d" width="170" height="20"></rect></g>
                                                    <g class="bar txtstart">
                                                    <rect fill=%s width="%d" height="18" x="%d" y="%d"></rect>
                                                    <text class="txtstart" fill="white" x="%d" y="%d" style="font-family:Play;font-size:14px">%s %s%%&nbsp;&nbsp;&nbsp;&nbsp;%s</text>
                                                    </g>]],jp,ib,d4,ft,jo,g(jd[i]*1.7+0.5)-2,d4+1,ft+1,d4+5,ft+14,bY,jd[i],jm)fs=fs-22;ft=ft-22 else eE=eE..cb(d4,fs,bY,eY.."pdim txtfuel")eE=eE..cb(d4,ft,n("%d%% %s",jd[i],jm),"pdim txtfuel","fill:"..jo)fs=fs+30;ft=ft+30 end end end end;iZ=fs end;if fuelX~=0 and fuelY~=0 then eE=cb(fuelX,fuelY,"","txtstart pdim txtfuel")iZ=fuelY;j8(fuelX,j7("atmo"),"ATMO",atmoTanks,iW,iX)j8(fuelX,j7("space"),"SPACE",spaceTanks,iU,iV)j8(fuelX,j7("rocket"),"ROCKET",rocketTanks,iS,iT)end end;local function jr()local dM=shield.isActive()and"Shield Active"or"Shield Disabled"local js=j.getPvPTimer()local jt=shield.getResistances()local ju="A: "..10+jt[1]*100 .."% / E: "..10+jt[2]*100 .."% / K:"..10+jt[3]*100 .."% / T: "..10+jt[4]*100 .."%"local d4,d5=shieldX-60,shieldY+30;local jn=g(shieldPercent*2.55)local jo=n("rgb(%d,%d,%d)",255-jn,jn,0)local eY=""eF=cb(d4,d5,"","txtmid pdim txtfuel")if shieldPercent<10 and dM~="Shield Disabled"then eY="red "end;js=js>0 and"   PvPTime: "..e5(js)or""eF=eF..n([[
                                <g class="pdim">                        
                                <rect fill=grey class="bar" x="%d" y="%d" width="200" height="13"></rect></g>
                                <g class="bar txtstart">
                                <rect fill=%s width="%d" height="13" x="%d" y="%d"></rect>
                                <text fill=black x="%d" y="%d">%s%%%s</text>
                                </g>]],d4,d5,jo,shieldPercent*2,d4,d5,d4+2,d5+10,shieldPercent,js)eF=eF..cb(d4,d5-5,dM,eY.."txtstart pbright txtbig")eF=eF..cb(d4,d5+30,ju,eY.."txtstart pbright txtsmall")end;local function jv()local eA="TRAVEL"if not throttleMode then eA="CRUISE"end;if Autopilot then eA="AUTOPILOT"end;return eA end;j6()eA=jv()if shield then jr()end;if AutopilotTargetName~="None"then if panelInterplanetary==nil then j2()end;if AutopilotTargetName~=nil then local gA;local jw=CustomTarget~=nil;local jx=Autopilot and AutopilotEndSpeed*3.6 or 0;bC(interplanetaryHeaderText,'{"label": "Target", "value": "'..AutopilotTargetName..'", "unit":""}')if jw and not Autopilot then gA=(worldPos-CustomTarget.position):len()else gA=(AutopilotTargetCoords-worldPos):len()end;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(velMag)ek,el=AP.GetAutopilotBrakeDistanceAndTime(adjMaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(velMag)ek,el=AP.GetAutopilotTBBrakeDistanceAndTime(adjMaxGameVelocity)end;local fL=e4(gA)bC(widgetDistanceText,'{"label": "distance", "value": "'..fL..'"}')bC(widgetTravelTimeText,'{"label": "Travel Time", "value": "'..e5(travelTime)..'", "unit":""}')fL=e4(brakeDistance)bC(widgetCurBrakeDistanceText,'{"label": "Cur Brake distance", "value": "'..fL..'"}')bC(widgetCurBrakeTimeText,'{"label": "Cur Brake Time", "value": "'..e5(brakeTime)..'", "unit":""}')fL=e4(ek)bC(widgetMaxBrakeDistanceText,'{"label": "Max Brake distance", "value": "'..fL..'"}')bC(widgetMaxBrakeTimeText,'{"label": "Max Brake Time", "value": "'..e5(el)..'", "unit":""}')bC(widgetStopSpeedText,'{"label": "End Speed", "value": "'..n("%.0fkph",jx)..'", "unit":""}')fL=e4(AutopilotTargetOrbit)bC(widgetTargetOrbitText,'{"label": "High Orbit", "value": "'..fL..'"}')bC(widgetTargetEngineText,'{"label": "Space Engine Alt", "value": "'..autopilotTargetPlanet.spaceEngineMinAltitude..'m"}')if inAtmo and not WasInAtmo then a.removeDataFromWidget(widgetMaxBrakeTimeText,widgetMaxBrakeTime)a.removeDataFromWidget(widgetStopSpeedText,widgetStopSpeed)a.removeDataFromWidget(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)a.removeDataFromWidget(widgetCurBrakeTimeText,widgetCurBrakeTime)a.removeDataFromWidget(widgetCurBrakeDistanceText,widgetCurBrakeDistance)a.removeDataFromWidget(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)WasInAtmo=true;if not throttleMode and AtmoSpeedAssist and(AltitudeHold or Reentry or finalLand)then AP.cmdThrottle(1)BrakeIsOn=false;WasInCruise=false end end;if not inAtmo and WasInAtmo then if bC(widgetMaxBrakeTimeText,widgetMaxBrakeTime)then bD(widgetMaxBrakeTimeText,widgetMaxBrakeTime)end;if bC(widgetMaxBrakeTimeText,widgetStopSpeed)then bD(widgetStopSpeedText,widgetStopSpeed)end;if bC(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)then bD(widgetMaxBrakeDistanceText,widgetMaxBrakeDistance)end;if bC(widgetCurBrakeTimeText,widgetCurBrakeTime)then bD(widgetCurBrakeTimeText,widgetCurBrakeTime)end;if bC(widgetCurBrakeDistanceText,widgetCurBrakeDistance)then bD(widgetCurBrakeDistanceText,widgetCurBrakeDistance)end;if bC(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)then bD(widgetTrajectoryAltitudeText,widgetTrajectoryAltitude)end;WasInAtmo=false end end else j5()end;if warpdrive~=nil then local jy=dY(warpdrive.getWidgetData())if jy.destination~="Unknown"and jy.distance>400000 then if not ex then warpdrive.showWidget()ex=true end elseif ex then warpdrive.hideWidget()ex=false end end end;function hF.OneSecondTick()local function jz()local jg=f()local fx=velMag;local jA=jg-ev;if fx>1.38889 then fx=fx/1000;local jB=fx*(jg-ev)TotalDistanceTravelled=TotalDistanceTravelled+jB;es=es+jB end;et=et+jA;TotalFlightTime=TotalFlightTime+jA;ev=jg end;local function jC(eH)local jD=0;local jE=e7;local jF=0;local jG=0;local jH=0;local jn=0;local jo=""local jI=b.getElementHitPointsById;local jJ=b.getElementMaxHitPointsById;local jK={}for N in pairs(e6)do local jL=0;local jM=0;jM=jJ(e6[N])jL=jI(e6[N])jF=jF+jL;if jL+1<jM then if jL==0 then jH=jH+1 else jG=jG+1 end;if ew and#jK==0 then position=vec3(b.getElementPositionById(e6[N]))local d4=position.x;local d5=position.y;local d6=position.z;table.insert(jK,b.spawnArrowSticker(d4,d5,d6+1,"down"))table.insert(jK,b.spawnArrowSticker(d4,d5,d6+1,"down"))b.rotateSticker(jK[2],0,0,90)table.insert(jK,b.spawnArrowSticker(d4+1,d5,d6,"north"))table.insert(jK,b.spawnArrowSticker(d4+1,d5,d6,"north"))b.rotateSticker(jK[4],90,90,0)table.insert(jK,b.spawnArrowSticker(d4-1,d5,d6,"south"))table.insert(jK,b.spawnArrowSticker(d4-1,d5,d6,"south"))b.rotateSticker(jK[6],90,-90,0)table.insert(jK,b.spawnArrowSticker(d4,d5-1,d6,"east"))table.insert(jK,b.spawnArrowSticker(d4,d5-1,d6,"east"))b.rotateSticker(jK[8],90,0,90)table.insert(jK,b.spawnArrowSticker(d4,d5+1,d6,"west"))table.insert(jK,b.spawnArrowSticker(d4,d5+1,d6,"west"))b.rotateSticker(jK[10],-90,0,90)table.insert(jK,e6[N])end elseif ew and#jK>0 and jK[11]==e6[N]then for jf in pairs(jK)do b.deleteSticker(jK[jf])end;jK={}end end;jD=bF(jF/jE*100,2)if jH>0 or jG>0 then eH[#eH+1]=cb(0,0,"","pbright txt")jn=g(jD*2.55)jo=n("rgb(%d,%d,%d)",255-jn,jn,0)eH[#eH+1]=cb("50%",1035,"Elemental Integrity: "..jD.."%","txtbig txtmid","fill:"..jo)if jH>0 then eH[#eH+1]=cb("50%",1055,"Disabled Modules: "..jH.." Damaged Modules: "..jG,"txtbig txtmid","fill:"..jo)elseif jG>0 then eH[#eH+1]=cb("50%",1055,"Damaged Modules: "..jG,"txtbig txtmid","fill:"..jo)end end end;local function jN()if weapon then if em==nil and(radarPanelId~=nil or GearExtended)then _autoconf.displayCategoryPanel(weapon,weapon_size,"Weapons","weapon",true)em=_autoconf.panels[_autoconf.panels_size]elseif em~=nil and radarPanelId==nil and not GearExtended then ca(em)em=nil end end end;local function jO()ez=""local jP="topButton"local jQ="topButtonActive"local jR=jP;if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then jR=jQ end;local jS=jP;if ProgradeIsOn then jS=jQ end;local jT=jP;if BrakeLanding or GearExtended then jT=jQ end;local jU=jP;if AltitudeHold or VectorToTarget then jU=jQ end;local jV=jP;if RetrogradeIsOn then jV=jQ end;local jW=jP;if IntoOrbit or OrbitAchieved and Autopilot then jW=jQ end;local jX=eC(30)ez=ez..n([[ 
                            <g class="pdim txt txtmid">
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],jR,eB(960),eC(54),eC(-53),eB(-120),eB(25),eC(50))ez=ez..cb(eB(910),jX,"AUTOPILOT")ez=ez..n([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],jS,eB(865),eC(51),eB(-25),eC(-50),eB(-110),eB(25),eC(46))ez=ez..cb(eB(800),jX,"PROGRADE")ez=ez..n([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],jT,eB(755),eC(47),eB(-25),eC(-46),eB(-98),eB(44),eC(44))ez=ez..cb(eB(700),jX,"LAND")ez=ez..n([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l 0 %f l %f 0 l %f %f Z"/>
                                ]],jU,eB(960),eC(54),eC(-53),eB(120),eB(-25),eC(50))ez=ez..cb(eB(1010),jX,"ALT HOLD")ez=ez..n([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],jV,eB(1055),eC(51),eB(25),eC(-50),eB(110),eB(-25),eC(46))ez=ez..cb(eB(1122),jX,"RETROGRADE")ez=ez..n([[
                                </g>
                
                                <g class="%s">
                                <path d="M %f %f l %f %f l %f 0 l %f %f Z"/>
                                ]],jW,eB(1165),eC(47),eB(25),eC(-46),eB(98),eB(-44),eC(44))ez=ez..cb(eB(1220),jX,"ORBIT")ez=ez..[[
                                </g>
                            </g>]]ez=ez.."</g>"end;local function jY()local function jZ()local j_;local p=planet;local k0=eB(1770)local k1=eC(330)if pipeDistC then local k2="txttick "local k3=500000;if pipeDistC<p.radius+k3 then if notPvPZone then k2="txttick red "else k2="txttick orange "end end;j_=e4(pipeDistC,2)ei=cb(k0,k1,"Closest Pipe ("..p.name.."--"..pipeDestC.name.."): "..j_,k2 .."pbright txtmid")if autopilotTargetPlanet and autopilotTargetPlanet.name~=planet.name and autopilotTargetPlanet.name~="Space"then j_=e4(pipeDistT,2)ei=ei..cb(k0,k1+15,"Target Pipe ("..p.name.."--"..autopilotTargetPlanet.name.."): "..j_,k2 .."pbright txtmid")end end end;if inAtmo then ei=""return end;jZ()end;local function k4(eH)local k5=eB(1240)local k6=eC(55)local k7=k6+10;local k8;local k9=0;if VertTakeOffEngine then eA=eA.."-VERTICAL"end;if CollisionSystem and cm and not AutoTakeoff and not BrakeLanding and velMag>20 then eA=eA.."-COLLISION ON"end;if UseExtra~="Off"then eA="("..UseExtra..")-"..eA end;if TurnBurn then eA="TB-"..eA end;if not stablized then eA=eA.."-DeCoupled"end;if alignTarget then eA="Alignment Lock-"..eA end;local ka=eC(99)local kb=eC(80)local kc=eC(85)local kd=eC(31)local ke=0;local kf=0;local a_=coreMass>1000000 and bF(coreMass/1000000,2).."kT"or bF(coreMass/1000,2).."T"if inAtmo then k9=LastMaxBrakeInAtmo else k9=LastMaxBrake end;local kg,kh=Kinematic.computeDistanceAndTime(velMag,0,coreMass,0,0,k9)if kg<0 then kg=0 end;k9=bF(k9/(coreMass*e8),2).."g"local ki=d:maxForceForward()k8=b.getGravityIntensity()if k8>0.1 then kf=coreMass*k8;kf=bF(kf/(coreMass*e8),2).."g"ke=0.5*ki/k8;ke=ke>1000000 and bF(ke/1000000,2).."kT"or bF(ke/1000,2).."T"end;ki=bF(ki/(coreMass*e8),2).."g"local kj=vec3(j.getWorldAcceleration()):len()/9.80665;k8=b.getGravityIntensity()eH[#eH+1]=[[<g class="dim txt txtend size14">]]if d_()and not RemoteHud then k5=eB(1120)k6=eC(55)k7=k6+10 elseif inAtmo and DisplayOdometer then local kk=eB(770)eH[#eH+1]=cb(eB(895),ka,"ATMO","")eH[#eH+1]=n([[<path class="linethin dimstroke"  d="M %f %f l %f 0"/>]],eB(895),kc,eB(-80))eH[#eH+1]=cb(eB(815),kb,n("%.1f%%",atmosDensity*100),"txtstart size20")end;if DisplayOdometer then eH[#eH+1]=cb(eB(1025),ka,"GRAVITY","txtstart")eH[#eH+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],eB(1025),kc,eB(80))eH[#eH+1]=cb(eB(1105),kb,n("%.2fg",k8/9.80665),"size20")eH[#eH+1]=cb(eB(1125),ka,"ACCEL","txtstart")eH[#eH+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],eB(1125),kc,eB(80))eH[#eH+1]=cb(eB(1205),kb,n("%.2fg",kj),"size20")eH[#eH+1]=cb(eB(695),ka,"BRK TIME","")eH[#eH+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],eB(695),kc,eB(-80))eH[#eH+1]=cb(eB(615),kb,n("%s",e5(kh)),"txtstart size20")eH[#eH+1]=cb(eB(635),eC(45),"TRIP","")eH[#eH+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],eB(635),eC(31),eB(-90))if travelTime then eH[#eH+1]=cb(eB(545),eC(26),n("%s",e5(travelTime)),"txtstart size20")end;eH[#eH+1]=cb(eB(795),ka,"BRK DIST","")eH[#eH+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],eB(795),kc,eB(-80))eH[#eH+1]=cb(eB(715),kb,n("%s",e4(kg)),"txtstart size20")eH[#eH+1]=cb(eB(1285),eC(45),"MASS","txtstart")eH[#eH+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],eB(1285),eC(31),eB(90))eH[#eH+1]=cb(eB(1375),eC(26),n("%s",a_),"size20")eH[#eH+1]=cb(eB(1220),ka,"THRUST","txtstart")eH[#eH+1]=n([[<path class="linethin dimstroke" d="M %f %f l %f 0"/>]],eB(1220),kc,eB(80))eH[#eH+1]=cb(eB(1300),kb,n("%s",ki),"size20")eH[#eH+1]=cb(eB(960),eC(175),eA,"pbright txtbig txtmid size20")end;eH[#eH+1]="</g>"end;local function kl(eH)if not SelectedTab or SelectedTab==""then SelectedTab="INFO"end;for N,A in pairs(ec)do local eY="dim brightstroke"local km=0.2;if SelectedTab==N then eY="pbright dimstroke"km=0.6 end;local kn=""if A.hovered then km=0.8;kn=";stroke:white"end;eH[#eH+1]=n([[<rect width="%f" height="%d" x="%d" y="%d" clip-path="url(#round-corner)" class="%s" style="stroke-width:1;fill-opacity:%f;%s" />]],A.width,A.height,A.x,A.y,eY,km,kn)eH[#eH+1]=cb(A.x+A.width/2,A.y+A.height/2+5,A.label,"txt txtmid pdim")end end;local function ko(es,TotalDistanceTravelled,et)ey=""local k8;local k9=0;local kf=0;local a_=coreMass>1000000 and bF(coreMass/1000000,2).." kTons"or bF(coreMass/1000,2).." Tons"if inAtmo then k9=LastMaxBrakeInAtmo else k9=LastMaxBrake end;local kg,kh=Kinematic.computeDistanceAndTime(velMag,0,coreMass,0,0,k9)local ki=d:maxForceForward()k8=b.getGravityIntensity()if k8<0.1 then k8=9.80665 end;local kp=vec3(j.getOrientationForward())local kq=j.getMaxThrustAlongAxis('thrust analog longitudinal ',{kp:unpack()})i6=0.5*kq[1]/k8;i6=i6>1000000 and bF(i6/1000000,1).." kTons"or bF(i6/1000,1).." Tons"i7=0.5*kq[3]/k8;i7=i7>1000000 and bF(i7/1000000,1).." kTons"or bF(i7/1000,1).." Tons"kp=vec3(j.getOrientationUp())kq=j.getMaxThrustAlongAxis('hover_engine, booster_engine',{kp:unpack()})i8=0.5*kq[1]/k8;i8=i8>1000000 and bF(i8/1000000,1).." kTons"or bF(i8/1000,1).." Tons"i9=0.5*k9/k8;i9=i9>1000000 and bF(i9/1000000,1).." kTons"or bF(i9/1000,1).." Tons"k9=bF(k9/(coreMass*e8),2).." g"kf=coreMass*k8;kf=bF(kf/(coreMass*e8),2).." g"ki=bF(ki/(coreMass*e8),2).." g"if not d_()or RemoteHud then local kr=eB(OrbitMapX+10)local ks=eC(OrbitMapY+20)local kt=eB(OrbitMapX+60*1920/ResolutionX+OrbitMapSize/2)local h5=25;ey=ey.."<g class='txtstart size14 bright'>"ey=ey..cb(kr,ks,n("BrkTime: %s",e5(kh)))ey=ey..cb(kt,ks,n("Trip: %.2f km",es))ey=ey..cb(kr,ks+h5,n("Lifetime: %.2f kSU",TotalDistanceTravelled/200000))ey=ey..cb(kt,ks+h5,n("BrkDist: %s",e4(kg)))ey=ey..cb(kr,ks+h5*2,"Trip Time: "..e5(et))ey=ey..cb(kt,ks+h5*2,"Total Time: "..e5(TotalFlightTime))ey=ey..cb(kr,ks+h5*3,n("Mass: %s",a_))ey=ey..cb(kt,ks+h5*3,n("Req Thrust: %s",kf))ey=ey..cb(kt,ks+h5*4,n("Safe Brake Mass: %s",i9))ey=ey..cb(kr,ks+h5*4,n("Max Thrust: %s",ki))ey=ey..cb(kt,ks+h5*5,n("Safe Atmo Mass: %s",i6))ey=ey..cb(kr,ks+h5*5,n("Max Brake: %s",k9))ey=ey..cb(kt,ks+h5*6,n("Safe Space Mass: %s",i7))ey=ey..cb(kt,ks+h5*7,n("Safe Hover Mass: %s",i8))ey=ey..cb(kr,ks+h5*6,n("Influence: %s",planet.name))ey=ey..cb(kr,ks+h5*7,n("Set Max Speed: %s",g(adjMaxGameVelocity*3.6+0.5)))ey=ey..cb(kt,ks+h5*8,n("Actual Max Speed: %s",g(MaxSpeed*3.6+0.5)))ey=ey..cb(kr,ks+h5*8,n("Burn Speed: %s",g(j.getFrictionBurnSpeed()*3.6)))end;ey=ey.."</g></g>"end;local eH={}jz()if ShouldCheckDamage then jC(eH)end;jN()jY()k4(eH)if SelectedTab=="INFO"then ko(es,TotalDistanceTravelled,et)end;if showHud then kl(eH)if DisplayOdometer then jO()end end;if pvpDist>50000 and not inAtmo then local ku=eB(1770)local kv=eC(310)local kw;kw=e4(pvpDist)eH[#eH+1]=cb(ku,kv,"PvP Boundary: "..kw,"pbright txtbig txtmid")end;eu=table.concat(eH,"")end;function hF.AnimateTick()Animated=true;Animating=false;simulatedX=0;simulatedY=0;c.stopTimer("animateTick")end;function hF.MsgTick()local eH={}hE(eH,"empty")msgText="empty"c.stopTimer("msgTick")msgTimer=3 end;function hF.ButtonSetup()hh()hm()e9=ea end;hG=n([[<path class="linethick brightstroke" style="fill:url(#RadialGradientCenterTop);" d="M %f %f L %f %f L %f %f %f %f L %f %f"/>
                <path class="linethick brightstroke" style="fill:url(#RadialGradientRightTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                
                <path class="linethick brightstroke" style="fill:url(#RadialGradientLeftTop);" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                
                <clipPath id="headingClip">
                    <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>
                </clipPath>
                <path class="linethick dimstroke" style="fill:black;fill-opacity:0.4;" d="M %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f L %f %f Z"/>]],eB(630),eC(0),eB(675),eC(45),eB(960),eC(55),eB(1245),eC(45),eB(1290),eC(0),eB(1000),eC(105),eB(1040),eC(59),eB(1250),eC(51),eB(1300),eC(0),eB(1920),eC(0),eB(1920),eC(20),eB(1400),eC(20),eB(1300),eC(105),eB(920),eC(105),eB(880),eC(59),eB(670),eC(51),eB(620),eC(0),eB(0),eC(0),eB(0),eC(20),eB(520),eC(20),eB(620),eC(105),eB(890),eC(59),eB(960),eC(62),eB(1030),eC(59),eB(985),eC(112),eB(1150),eC(112),eB(1100),eC(152),eB(820),eC(152),eB(780),eC(112),eB(935),eC(112),eB(890),eC(59),eB(960),eC(62),eB(1030),eC(59),eB(985),eC(112),eB(1150),eC(112),eB(1100),eC(152),eB(820),eC(152),eB(780),eC(112),eB(935),eC(112))if userHud then for N,A in pairs(userHud)do hF[N]=A end end;return hF end;local function kx(d,b,c,l,vBooster,hover,telemeter_1,antigrav,dbHud_1,aV,g,h,d_,atan,f,o,e0,bC,e1,r,bF,bE,e2,s,e4,e5,ky,dY,k)local a=DUSystem;local j=DUConstruct;local kz={}local kA=false;local kB=0;local kC=0;local kD=0;local kE=f()local kF=0;local kG=0;local kH=0;local kI=0;local kJ=false;local kK=false;local kL=false;local kM=nil;local kN=0;local ej=55;local kO=nil;local kP=false;local kQ=false;local kR=false;local kS=0;local kT=0;local kU=0;local kV=0;local kW=0;local kX={VectorToTarget=false}local kY=vec3(j.getWorldOrientationUp())local kZ=nil;local k_=0;local l0=false;local l1=false;local l2=false;local l3=false;local l4=false;local l5=false;local l6=""local l7=false;local l8=false;local l9=""local la=false;local lb=0;local lc=0;local ld=c.getThrottle()local function le()return not j.isInPvPZone(),aV(j.getDistanceToSafeZone())end;local function lf(f9)local lg=AutopilotEndSpeed;if not Autopilot then lg=0 end;local lh=LastMaxBrake;if inAtmo then if LastMaxBrakeInAtmo and LastMaxBrakeInAtmo>0 then lh=LastMaxBrakeInAtmo else return 0,0 end end;return Kinematic.computeDistanceAndTime(f9,lg,coreMass,0,0,lh)end;local function li(f9)local lg=AutopilotEndSpeed;if not Autopilot then lg=0 end;return Kinematic.computeDistanceAndTime(f9,lg,coreMass,d:maxForceForward(),warmup,LastMaxBrake)end;local function lj(lk,ll,lm)ll=ll:project_on_plane(lk)lm=lm:project_on_plane(lk)return atan(ll:cross(lm):dot(lk),ll:dot(lm))end;local ln=-1;local lo=-1;local function lp()local function lq()local lr=-1;local ls=-1;if vBooster then lr=vBooster.getDistance()if lr>-1 and lr<0.01 then lr=ln else ln=lr end end;if hover then ls=hover.getDistance()if ls>-1 and ls<0.01 then ls=lo else lo=ls end end;if lr~=-1 and ls~=-1 then if lr<ls then return lr else return ls end elseif lr~=-1 then return lr elseif ls~=-1 then return ls else return-1 end end;local lt=lq()local lu=-1;if antigrav and antigrav.isActive()and not ExternalAGG and velMag<ej then local lv=aV(coreAltitude-antigrav.getBaseAltitude())if lv<50 then return lv end end;if telemeter_1 then lu=telemeter_1.raycast().distance;if lu==0 then lu=-1 end end;if lt~=-1 and lu~=-1 then if lt<lu then return lt else return lu end elseif lt~=-1 then return lt else return lu end end;local function lw(planet,aI,lx)local function ly(lz,Y)local aO=vec3(Y)if lz.id==0 then return setmetatable({latitude=aO.x,longitude=aO.y,altitude=aO.z,id=0,systemId=lz.systemId},MapPosition)end;local aP=aO-lz.center;local distance=aP:len()local a4=distance-lz.radius;local a2=0;local a3=0;if not s(distance,0)then local aQ=atan(aP.y,aP.x)a3=aQ>=0 and aQ or 2*math.pi+aQ;a2=math.pi/2-math.acos(aP.z/distance)end;return setmetatable({latitude=math.deg(a2),longitude=math.deg(a3),altitude=a4,id=lz.id,systemId=lz.systemId},MapPosition)end;local lA=ly(planet,aI)lA="::pos{"..lA.systemId..","..lA.id..","..lA.latitude..","..lA.longitude..","..lA.altitude.."}"if lx then return lA else l4=lA;return true end end;local function lB(lC,lD,lE)local function lF(lC,ar)lC=vec3(lC)ar=vec3(ar):normalize()local I=lC*ar;return I.x+I.y+I.z end;local lG=0.001;local lH=1;if not inAtmo or not stalling or abvGndDet~=-1 or velMag<ej then if lE==nil then lE=DampingMultiplier end;if lD==nil then lD=lG end;lC=vec3(lC):normalize()local lI=vec3()-lC;local lJ=-lF(lI,j.getWorldOrientationRight())*lH;local lK=-lF(lI,j.getWorldOrientationUp())*lH;if kC==0 then kC=lJ/2 end;if kD==0 then kD=lK/2 end;if aV(lJ)<0.1 then kT=kT-lJ*2 else kT=kT-(lJ+(lJ-kC)*lE)end;if aV(lK)<0.1 then kS=kS+lK*2 else kS=kS+lK+(lK-kD)*lE end;kC=lJ;kD=lK;if aV(lJ)<lD and aV(lK)<lD then return true end;return false elseif stalling and abvGndDet==-1 then lC=constructVelocity;if lE==nil then lE=DampingMultiplier end;if lD==nil then lD=lG end;lC=vec3(lC):normalize()local lI=constructForward-lC;local lJ=-lF(lI,j.getWorldOrientationRight())*lH;local lK=-lF(lI,j.getWorldOrientationUp())*lH;if kC==0 then kC=lJ/2 end;if kD==0 then kD=lK/2 end;if aV(lJ)<0.1 then kT=kT-lJ*5 else kT=kT-(lJ+(lJ-kC)*lE)end;if aV(lK)<0.1 then kS=kS+lK*5 else kS=kS+lK+(lK-kD)*lE end;kC=lJ;kD=lK;if aV(lJ)<lD and aV(lK)<lD then return true end;return false end end;function kz.clearAll()AutopilotAccelerating=false;AutopilotBraking=false;AutopilotCruising=false;Autopilot=false;AutopilotRealigned=false;AutopilotStatus="Aligning"RetrogradeIsOn=false;ProgradeIsOn=false;ReversalIsOn=nil;AltitudeHold=false;Reentry=false;BrakeLanding=false;AutoTakeoff=false;VertTakeOff=false;followMode=false;kQ=false;spaceLand=false;spaceLaunch=false;kR=false;autoRoll=autoRollPreference;VectorToTarget=false;TurnBurn=false;gyroIsOn=false;LockPitch=nil;IntoOrbit=false;apBrk=false;alignHeading=nil;finalLand=false;AP.ResetAutopilots(1)end;function kz.GetAutopilotBrakeDistanceAndTime(f9)return lf(f9)end;function kz.GetAutopilotTBBrakeDistanceAndTime(f9)return li(f9)end;function kz.showWayPoint(planet,aI,lx)return lw(planet,aI,lx)end;local lL=a.getAxisValue(3)local lM=a.getAxisValue(4)local lN=a.getAxisValue(5)function kz.APTick()local lO=a.getMouseWheel()if throttleMode then local lP=a.getAxisValue(3)if lP~=lL then if AtmoSpeedAssist then PlayerThrottle=lP else e0:setThrottleCommand(axisCommandId.longitudinal,lP)end;lL=lP end;lP=a.getAxisValue(4)if lP~=lM then e0:setThrottleCommand(axisCommandId.lateral,lP)LeftAmount=lP;lM=lP end;lP=a.getAxisValue(5)if lP~=lN then e0:setThrottleCommand(axisCommandId.vertical,lP)upAmount=lP;lN=lP end end;if lO>0 then AP.changeSpd()elseif lO<0 then AP.changeSpd(true)else kP=true end;l1=e1()if l4 then a.setWaypoint(l4)l4=false end;if l7 then antigrav.setTargetAltitude(l7)l7=false end;if l5 then bC(l5,l6)l5=false;l6=""end;if kZ~=nil then if e0:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then d.control.cancelCurrentControlMasterMode()end;if e0:getTargetSpeed(axisCommandId.longitudinal)~=kZ then e0:setTargetSpeedCommand(axisCommandId.longitudinal,kZ)else kZ=nil end end;if l0 then CONTROL.landingGear(l0)l0=false end;if l8 then AP.ToggleAutopilot()end end;function kz.ToggleIntoOrbit(lQ)OrbitAchieved=false;kH=nil;kI=nil;kN=0;kK=false;if not inAtmo then if IntoOrbit then bE("orOff","AP")IntoOrbit=false;kJ=false;kM=nil;autoRoll=autoRollPreference;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end;kX.VectorToTarget=false;kX.AutopilotAlign=false;kL=false elseif nearPlanet then bE("orOn","AP")IntoOrbit=true;autoRoll=true;if kM==nil then kM=lQ or planet end;if AltitudeHold then AltitudeHold=false;AutoTakeoff=false end else k("Unable to engage auto-orbit, not near a planet")end else IntoOrbit=false;kJ=false;kM=nil;autoRoll=autoRollPreference;if AltitudeHold then AltitudeHold=false end;kX.VectorToTarget=false;kX.AutopilotAlign=false;kL=false end end;function kz.ToggleVerticalTakeoff()AltitudeHold=false;if VertTakeOff then StrongBrakes=true;Reentry=false;AutoTakeoff=false;BrakeLanding=true;autoRoll=true;upAmount=0;if inAtmo and abvGndDet==-1 then BrakeLanding=false;AltitudeHold=true;upAmount=0;d:setEngineForceCommand('thrust analog vertical fueled ',vec3(),1)AP.cmdThrottle(1)AP.cmdCruise(g(adjustedAtmoSpeedLimit))end else OrbitAchieved=false;GearExtended=false;d.control.retractLandingGears()e0:setTargetGroundAltitude(TargetHoverHeight)BrakeIsOn="VTO Takeoff"end;VertTakeOff=not VertTakeOff end;function kz.checkLOS(lC)local fO,aG,aH=galaxyReference:getPlanetarySystem(0):castIntersections(worldPos,lC,function(ap)if ap.noAtmosphericDensityAltitude>0 then return ap.radius+ap.noAtmosphericDensityAltitude else return ap.radius+ap.surfaceMaxAltitude*1.1 end end)local fP=aG;if aH~=nil and aG~=nil then fP=math.min(aH,aG)end;if fP~=nil then return fO,fP else return nil,nil end end;local function lR(lS,lT)if lT then upAmount=0;e0:updateCommandFromActionStop(axisCommandId.vertical,lT)if stablized then e0:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)sEFC=true end else upAmount=upAmount+lS;e0:deactivateGroundEngineAltitudeStabilization()e0:updateCommandFromActionStart(axisCommandId.vertical,lS)end end;function kz.vertical(lS,lT)lR(lS,lT)end;function kz.ToggleAutopilot()local function lU(SpaceTarget)collisionAlertStatus=false;VectorToTarget=not VectorToTarget;if VectorToTarget then TurnBurn=false;if not AltitudeHold and not SpaceTarget then AP.ToggleAltitudeHold()end end;VectorStatus="Proceeding to Waypoint"end;local function lV(bY)if bY then for i,N in pairs(AtlasOrdered)do if N.name and N.name==bY then return i end end else return 0 end end;local lW=false;if time-kG<1.5 and inAtmo then if not SpaceEngines then if inAtmo then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bE("11","EP")kG=-1;if Autopilot or VectorToTarget or IntoOrbit then return end else k("No space engines detected, Orbital Hop not supported")return end elseif planet.hasAtmosphere then if inAtmo then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;bE("orH","OH")end;kG=-1;if Autopilot or VectorToTarget or IntoOrbit then return end end else kG=time end;TargetSet=false;alignTarget=false;if(AutopilotTargetIndex>0 or#apRoute>0)and not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit then if 0.5*d:maxForceForward()/b.getGravityIntensity()<coreMass then k("WARNING: Heavy Loads may affect autopilot performance.")end;AutopilotTargetIndex=#apRoute>0 and not finalLand and lV(apRoute[1])or AutopilotTargetIndex;ATLAS.UpdateAutopilotTarget()if#apRoute>0 and not finalLand then k("Route Autopilot in Progress")if(CustomTarget.position-worldPos):project_on_plane(worldVertical):len()>50000 and CustomTarget.planetname==planet.name then lW=true end end;AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)if CustomTarget~=nil then if CustomTarget.agg and not ExternalAGG and antigrav then if not antigravOn then AP.ToggleAntigrav()end;AntigravTargetAltitude=CustomTarget.agg end;LockPitch=nil;SpaceTarget=CustomTarget.planetname=="Space"if SpaceTarget then bE("apSpc","AP")if inAtmo then spaceLaunch=true;AP.ToggleAltitudeHold()else Autopilot=true end elseif planet.name==CustomTarget.planetname then StrongBrakes=true;if inAtmo then if not VectorToTarget then bE("vtt","AP")lU(SpaceTarget)if lW then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight end end else bE("apOn","AP")if not(autopilotTargetPlanet.name==planet.name and coreAltitude<AutopilotTargetOrbit*1.5)then OrbitAchieved=false;Autopilot=true elseif not inAtmo then if IntoOrbit then AP.ToggleIntoOrbit()end;OrbitTargetOrbit=(autopilotTargetPlanet.noAtmosphericDensityAltitude>0 and autopilotTargetPlanet.noAtmosphericDensityAltitude or autopilotTargetPlanet.surfaceMaxAltitude)+LowOrbitHeight;kL=true;kX.AutopilotAlign=true;kX.VectorToTarget=true;kJ=false;if not IntoOrbit then AP.ToggleIntoOrbit(autopilotTargetPlanet)end end end else bE("apP","AP")RetrogradeIsOn=false;ProgradeIsOn=false;if inAtmo then spaceLaunch=true;AP.ToggleAltitudeHold()else Autopilot=true end end elseif not inAtmo then if CustomTarget==nil and(autopilotTargetPlanet.name==planet.name and nearPlanet)and not IntoOrbit then WaypointSet=false;OrbitAchieved=false;kJ=false;OrbitTargetOrbit=(planet.noAtmosphericDensityAltitude>0 and planet.noAtmosphericDensityAltitude or planet.surfaceMaxAltitude)+LowOrbitHeight;kL=true;AP.ToggleIntoOrbit()else bE("apP","AP")Autopilot=true;RetrogradeIsOn=false;ProgradeIsOn=false;AutopilotRealigned=false;followMode=false;AltitudeHold=false;BrakeLanding=false;Reentry=false;AutoTakeoff=false;kQ=false;LockPitch=nil;WaypointSet=false end else bE("apP","AP")spaceLaunch=true;AP.ToggleAltitudeHold()end;l8=false else bE("apOff","AP")AP.clearAll()if l8==2 then l8=true end end end;function kz.routeWP(lX,lY,lZ)if lZ then if lZ==1 then apRoute={}apRoute=e2(apRoute,saveRoute)if#apRoute>0 then k("Route Loaded")else k("No Saved Route found on Databank")end;return apRoute else saveRoute={}saveRoute=e2(saveRoute,apRoute)k("Route Saved")ky()return end end;if lX then return apRoute end;if lY then apRoute={}k("Current Route Cleared")else apRoute[#apRoute+1]=CustomTarget.name;k("Added "..CustomTarget.name.." to route. ")end;return apRoute end;function kz.cmdThrottle(O,l_)if e0:getAxisCommandType(0)~=axisCommandType.byThrottle and not l_ then d.control.cancelCurrentControlMasterMode()end;e0:setThrottleCommand(axisCommandId.longitudinal,O)PlayerThrottle=o(bF(O*100,0)/100,-1,1)kZ=nil end;function kz.cmdCruise(O,l_)if kZ then kZ=O;return end;if e0:getAxisCommandType(0)~=axisCommandType.byTargetSpeed and not l_ then d.control.cancelCurrentControlMasterMode()end;e0:setTargetSpeedCommand(axisCommandId.longitudinal,O)kZ=O end;function kz.ToggleLockPitch()if LockPitch==nil then bE("lkPOn","LP")LockPitch=adjustedPitch;AutoTakeoff=false;AltitudeHold=false;BrakeLanding=false else bE("lkPOff","LP")LockPitch=nil end end;function kz.ToggleAltitudeHold()if time-kF<1.5 then if planet.hasAtmosphere then if inAtmo then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude;bE("11","EP")else if nearPlanet then HoldAltitude=planet.noAtmosphericDensityAltitude+LowOrbitHeight;OrbitTargetOrbit=HoldAltitude;kL=true;if not IntoOrbit then AP.ToggleIntoOrbit()end;kJ=true end end;kF=-1;if AltitudeHold or IntoOrbit or VertTakeOff then return end end else kF=time end;if nearPlanet and not inAtmo and abvGndDet==-1 then OrbitTargetOrbit=coreAltitude;kL=true;kJ=true;AP.ToggleIntoOrbit()if IntoOrbit then kF=time else kF=0 end;return end;AltitudeHold=not AltitudeHold;BrakeLanding=false;Reentry=false;alignTarget=false;if AltitudeHold then Autopilot=false;ProgradeIsOn=false;RetrogradeIsOn=false;followMode=false;autoRoll=true;LockPitch=nil;OrbitAchieved=false;if abvGndDet~=-1 then if velMag<20 then if GearExtended then CONTROL.landingGear()end;bE("lfs","LS")AutoTakeoff=true;if inAtmo then HoldAltitude=coreAltitude+AutoTakeoffAltitude else HoldAltitude=planet.surfaceMaxAltitude+100 end;BrakeIsOn="ATO Hold"e0:setTargetGroundAltitude(TargetHoverHeight)if VertTakeOffEngine and UpVertAtmoEngine then AP.ToggleVerticalTakeoff()end end else bE("altOn","AH")AutoTakeoff=false;if kF>-1 then if nearPlanet then HoldAltitude=coreAltitude end end;if VertTakeOff then AP.ToggleVerticalTakeoff()end end;if antigravOn and not ExternalAGG then local m0=antigrav.getBaseAltitude()if VectorToTarget and CustomTarget.agg and CustomTarget.agg>coreAltitude then HoldAltitude=CustomTarget.agg elseif AutoTakeoff then HoldAltitude=m0 end;if aV(coreAltitude-m0)<100 and velMag<20 then HoldAltitude=m0;BrakeIsOn="AGG Hold"AP.cmdThrottle(0)end end;if spaceLaunch then HoldAltitude=200000 end else bE("altOff","AH")if IntoOrbit then AP.ToggleIntoOrbit()end;if VertTakeOff then AP.ToggleVerticalTakeoff()end;autoRoll=autoRollPreference;AutoTakeoff=false;VectorToTarget=false;kF=0 end end;function kz.ResetAutopilots(kz)if kz then spaceLaunch=false;Autopilot=false;AutopilotRealigned=false;kQ=false;HoldAltitude=coreAltitude;TargetSet=false;apBrk=false;AutopilotStatus="Aligning"end;VectorToTarget=false;AutoTakeoff=false;Reentry=false;alignTarget=false;ProgradeIsOn=false;BrakeLanding=false;alignHeading=nil;AutoLanding=false;ReversalIsOn=nil;apBrk=false;if not antigravOn then AltitudeHold=false;LockPitch=nil end;if VertTakeOff then AP.ToggleVerticalTakeoff()end;if IntoOrbit then AP.ToggleIntoOrbit()end;autoRoll=autoRollPreference;spaceLand=false;finalLand=false;upAmount=0 end;function kz.BrakeToggle(m1)if not BrakeIsOn then if m1 then BrakeIsOn=m1 else BrakeIsOn=true end else BrakeIsOn=false end;if BrakeLanding then BrakeLanding=false;autoRoll=autoRollPreference;apBrk=false end;if BrakeIsOn then bE("bkOn","B",1)AP.ResetAutopilots()else bE("bkOff","B",1)end end;function kz.BeginReentry()if Reentry then k("Re-Entry cancelled")bE("reOff","RE")Reentry=false;autoRoll=autoRollPreference;AltitudeHold=false elseif not planet.hasAtmosphere then k("Re-Entry requirements not met: you must start out of atmosphere\n and within a planets gravity well over a planet with atmosphere")msgTimer=5 elseif not kR then Reentry=true;if e0:getAxisCommandType(0)~=controlMasterModeId.cruise then d.control.cancelCurrentControlMasterMode()end;autoRoll=true;BrakeIsOn=false;k("Beginning Parachute Re-Entry - Strap In.  Target speed: "..adjustedAtmoSpeedLimit)bE("par","RE")else Reentry=true;AltitudeHold=true;autoRoll=true;BrakeIsOn=false;HoldAltitude=planet.surfaceMaxAltitude+ReEntryHeight;if HoldAltitude>planet.spaceEngineMinAltitude then HoldAltitude=planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude end;local m2=e4(HoldAltitude)k("Beginning Re-entry.  Target speed: "..adjustedAtmoSpeedLimit.." Target Altitude: "..m2)bE("glide","RE")AP.cmdCruise(g(adjustedAtmoSpeedLimit))end;AutoTakeoff=false end;function kz.ToggleAntigrav()if antigrav and not ExternalAGG then if antigravOn then bE("aggOff","AG")antigrav.deactivate()antigrav.hideWidget()else if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;bE("aggOn","AG")antigrav.activate()antigrav.showWidget()end end end;function kz.changeSpd(m3)local m4=1;if m3 then m4=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn and kP then local m5=PlayerThrottle;PlayerThrottle=bF(o(PlayerThrottle+m4*speedChangeLarge/100,-1,1),2)if PlayerThrottle>=0 and m5<0 then PlayerThrottle=0;kP=false end elseif AltIsOn then if inAtmo or Reentry then adjustedAtmoSpeedLimit=o(adjustedAtmoSpeedLimit+m4*speedChangeLarge,0,AtmoSpeedLimit)elseif Autopilot then adjMaxGameVelocity=o(adjMaxGameVelocity+m4*speedChangeLarge/3.6*100,0,MaxSpeed-0.2)end else e0:updateCommandFromActionStart(axisCommandId.longitudinal,m4*speedChangeLarge/10)end else if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then apScrollIndex=apScrollIndex+1*m4*-1;if apScrollIndex>#AtlasOrdered then apScrollIndex=1 end;if apScrollIndex<1 then apScrollIndex=#AtlasOrdered end else if not m3 then m4=1 else m4=nil end;ATLAS.adjustAutopilotTargetIndex(m4)end end end;function kz.TenthTick()local function m6()if not Autopilot then if CustomTarget==nil or CustomTarget.planetname~=planet.name then AutopilotDistance=(autopilotTargetPlanet.center-worldPos):len()else AutopilotDistance=(CustomTarget.position-worldPos):len()end end;local f9=velMag;local m7=AtmoSpeedAssist and PlayerThrottle or ld/100;local m8,m9=Kinematic.computeDistanceAndTime(velMag,adjMaxGameVelocity,coreMass,d:maxForceForward()*m7,warmup,0)local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=AP.GetAutopilotBrakeDistanceAndTime(adjMaxGameVelocity)else brakeDistance,brakeTime=AP.GetAutopilotTBBrakeDistanceAndTime(adjMaxGameVelocity)end;local _,ma;if not TurnBurn and f9>0 then _,ma=AP.GetAutopilotBrakeDistanceAndTime(f9)else _,ma=AP.GetAutopilotTBBrakeDistanceAndTime(f9)end;local mb=0;local mc=0;if AutopilotCruising or not Autopilot and f9>5 then mc=Kinematic.computeTravelTime(f9,0,AutopilotDistance)elseif brakeDistance+m8<AutopilotDistance then mb=AutopilotDistance-(brakeDistance+m8)mc=Kinematic.computeTravelTime(adjMaxGameVelocity,0,mb)else local md=(AutopilotDistance-brakeDistance)/m8;m8=AutopilotDistance-brakeDistance;m9=m9*md end;if CustomTarget~=nil and CustomTarget.planetname==planet.name and not Autopilot then return mc elseif AutopilotBraking then return ma elseif AutopilotCruising then return mc+ma else return m9+brakeTime+mc end end;local function me()local k8=b.getGravityIntensity()k8=bF(k8,5)if kO==nil or kO~=k8 then local f9=coreVelocity:len()local mf=j.getMaxBrake()if mf~=nil and mf>0 and inAtmo then mf=mf/o(f9/100,0.1,1)mf=mf/atmosDensity;if atmosDensity>0.10 then LastMaxBrakeInAtmo=mf end end;if mf~=nil and mf>0 then LastMaxBrake=mf end;kO=k8 end end;local function mg(mh,mi)local j_;local mj=(mi-mh):normalize()local bh=(worldPos-mh):dot(mj)/mj:dot(mj)local mk=mh+bh*mj;j_=(mk-worldPos):len()return j_,mk end;local function ml()local mm,mn=nil,nil;local mo=nil;local mp=nil;local mq,mr,ms=planet.center,nil,planet.name;for N,mt in pairs(l[0])do mr=mt.center;if mr and mt.name~=ms and string.find(mt.name,"Asteroid")==nil and mt.name~="Space"then local distance,mm=mg(mq,mr)if mo==nil or distance<mo then mp=mt;mn=mm;mo=distance end end end;if mn then pipePosC=mn;pipeDestC=mp;pipeDistC=mo end;if autopilotTargetPlanet then if autopilotTargetPlanet.name~=ms and autopilotTargetPlanet.name~="Space"then pipeDistT,pipePosT=mg(mq,autopilotTargetPlanet.center)pipeDestT=autopilotTargetPlanet end end end;ships=j.getDockedConstructs()passengers=j.getPlayersOnBoard()lc=0;for i=1,#ships do lc=lc+j.getDockedConstructMass(ships[i])end;local mu=0;for i=1,#passengers do mu=mu+j.getBoardedPlayerMass(passengers[i])end;if mu>20000 then lc=lc+mu-20000 end;notPvPZone,pvpDist=le()MaxSpeed=j.getMaxSpeed()if AutopilotTargetName~="None"and(autopilotTargetPlanet or CustomTarget)then travelTime=m6()end;me()ml()end;local mv=pid.new(10,0,10.0)local function mw(mx,my)local kp=vec3()local mz=vec3()if mx==axisCommandId.longitudinal then kp=vec3(j.getOrientationForward())mz=constructForward elseif mx==axisCommandId.vertical then kp=vec3(j.getOrientationUp())mz=kY elseif mx==axisCommandId.lateral then kp=vec3(j.getOrientationRight())mz=constructRight else return vec3()end;local mA=vec3(b.getWorldGravity())local mB=mA:dot(mz)local mC=vec3(j.getWorldAirFrictionAcceleration())local mD=mC:dot(mz)local mE=coreVelocity:dot(kp)local mF=my*constants.kph2m;mv:inject(mF-mE)local mG=mv:get()local mH=(mG-mD-mB)*mz;return mH end;local mI=pid.new(10,0,10.0)local function mJ(mx,my)local kp=vec3()local mz=vec3()if mx==axisCommandId.longitudinal then kp=vec3(j.getOrientationForward())mz=constructForward elseif mx==axisCommandId.vertical then kp=vec3(j.getOrientationUp())mz=kY elseif mx==axisCommandId.lateral then kp=vec3(j.getOrientationRight())mz=constructRight else return vec3()end;local mA=vec3(b.getWorldGravity())local mB=mA:dot(mz)local mC=vec3(j.getWorldAirFrictionAcceleration())local mD=mC:dot(mz)local mE=coreVelocity:dot(kp)local mF=my*constants.kph2m;mI:inject(mF-mE)local mG=mI:get()local mH=(mG-mD-mB)*mz;return mH end;local function mK(mL,hV,bK)local mM=mL:cross(bK):normalize_inplace()local f5=math.acos(o(mM:dot(-hV),-1,1))*constants.rad2deg;if mM:cross(-hV):dot(bK)<0 then f5=-f5 end;return f5 end;local function mN()if collisionTarget and not BrakeLanding then local ap=collisionTarget[1]local dt,du=collisionTarget[2],collisionTarget[3]local mO=math.min(dt,du or dt)local mP=mO/velMag;local mQ=AutoTakeoff and(velMag<42 or abvGndDet~=-1)local mR=AltitudeHold or VectorToTarget or LockPitch or Autopilot;if mR and not mQ and(brakeDistance*1.5>mO or mP<1)then BrakeIsOn="Collision"apRoute={}AP.cmdThrottle(0)if AltitudeHold then AP.ToggleAltitudeHold()end;if LockPitch then AP.ToggleLockPitch()end;k("Autopilot Cancelled due to possible collision")a.print(ap.name.." COLLISION "..e5(mP).." / "..e4(mO,2))AP.clearAll()StrongBrakes=true;if inAtmo then BrakeLanding=true end;autoRoll=true end;if mP<11 then collisionAlertStatus=ap.name.." COLLISION "..e5(mP).." / "..e4(mO,2)else collisionAlertStatus=ap.name.." collision "..e5(mP)end;if mP<6 then bE("alarm","AL",2)end else collisionAlertStatus=false end end;local mS=1;local mT=0;local mU=1;local mV=1;local mW=1;local mX=false;local mY=pid.new(0.1,0,1*0.1)local mZ=pid.new(1*0.01,0,5*0.1)local m_=pid.new(autoRollFactor*0.01,0,autoRollFactor*0.1)local n0=pid.new(2*0.01,0,2*0.1)local mZ=pid.new(1*0.01,0,5*0.1)local n1=pid.new(2*0.01,0,2*0.1)local n2=pid.new(2*0.01,0,2*0.1)local n3=pid.new(2*0.01,0,2*0.1)local n4=pid.new(2*0.01,0,2*0.1)local n5=pid.new(0.1,0,1)local n6=pid.new(1*0.01,0,1*0.1)function kz.onFlush()if antigrav and not ExternalAGG and not antigravOn and antigrav.getBaseAltitude()~=AntigravTargetAltitude then l7=AntigravTargetAltitude end;if sEFC then d:setEngineForceCommand('hover',vec3(),1)sEFC=false end;throttleMode=e0:getAxisCommandType(0)==axisCommandType.byThrottle;pitchSpeedFactor=math.max(pitchSpeedFactor,0.01)yawSpeedFactor=math.max(yawSpeedFactor,0.01)rollSpeedFactor=math.max(rollSpeedFactor,0.01)torqueFactor=math.max(torqueFactor,0.01)brakeSpeedFactor=math.max(brakeSpeedFactor,0.01)brakeFlatFactor=math.max(brakeFlatFactor,0.01)autoRollFactor=math.max(autoRollFactor,0.01)ld=c.getThrottle()local n7=a.getAxisValue(1)if n7==0 then n7=a.getControlDeviceForwardInput()end;local n8=o(pitchInput+kS+n7,-1,1)local n9=a.getAxisValue(0)if n9==0 then n9=a.getControlDeviceYawInput()end;local na=o(rollInput+kU+n9,-1,1)local nb=a.getAxisValue(2)if nb==0 then nb=a.getControlDeviceLeftRightInput()end;local nc=o(yawInput+kT-nb,-1,1)local nd=BrakeIsOn and 1 or 0;if inAtmo then worldVertical=vec3(b.getWorldVertical())if worldVertical==nil or worldVertical:len()==0 then worldVertical=(planet.center-worldPos):normalize()end else worldVertical=(planet.center-worldPos):normalize()end;kY=vec3(j.getWorldOrientationUp())constructForward=vec3(j.getWorldOrientationForward())constructRight=vec3(j.getWorldOrientationRight())constructVelocity=vec3(j.getWorldVelocity())coreVelocity=vec3(j.getVelocity())worldPos=vec3(j.getWorldPosition())coreMass=j.getMass()+lc;velMag=vec3(constructVelocity):len()vSpd=-worldVertical:dot(constructVelocity)adjustedRoll=getRoll(worldVertical,constructForward,constructRight)local ne=adjustedRoll/180*math.pi;local nf=math.cos(ne)local ng=math.sin(ne)adjustedPitch=mK(worldVertical,constructForward,constructRight*nf+kY*ng)local nh=constructVelocity:normalize()local ni=aV(adjustedRoll)local nj=utils.sign(adjustedRoll)local nk=vec3(j.getWorldAngularVelocity())local nl=n8*pitchSpeedFactor*constructRight+na*rollSpeedFactor*constructForward+nc*yawSpeedFactor*kY;if autoRoll==true and worldVertical:len()>0.01 then local nm=aV(kV-adjustedRoll)if((ProgradeIsOn or Reentry or BrakeLanding or spaceLand or AltitudeHold or IntoOrbit)and nm>0 or inAtmo and nm<autoRollRollThreshold and autoRollPreference)and na==0 and aV(adjustedPitch)<85 then local nn=kV;if not inAtmo then kV=0;nn=0 end;m_:inject(nn-adjustedRoll)local no=m_:get()nl=nl+no*constructForward end end;local function np()local nq=(worldPos+constructVelocity*100000-autopilotTargetPlanet.center):normalize()local nr=nq:project_on_plane((autopilotTargetPlanet.center-worldPos):normalize()):normalize()if nr:len()<1 then nq=(worldPos+constructForward*100000-autopilotTargetPlanet.center):normalize()nr=nq:project_on_plane((autopilotTargetPlanet.center-worldPos):normalize()):normalize()end;return autopilotTargetPlanet.center+nr*(autopilotTargetPlanet.radius+AutopilotTargetOrbit)end;brakeInput2=0;atmosDensity=h()inAtmo=false or coreAltitude<planet.noAtmosphericDensityAltitude and atmosDensity>0.00001;coreAltitude=(worldPos-planet.center):len()-planet.radius;abvGndDet=lp()time=f()kE=time;if GearExtended and abvGndDet>-1 and abvGndDet-3<LandingGearGroundHeight then if e0.targetGroundAltitudeActivated then e0:deactivateGroundEngineAltitudeStabilization()end;e0:updateCommandFromActionStart(axisCommandId.vertical,-1)end;if RADAR then la=not la;if la then RADAR.UpdateRadar()end;if CollisionSystem then mN()end end;if antigrav then antigravOn=antigrav.isActive()end;local ns=time-kE;local nt=-math.deg(lj(kY,constructVelocity,constructForward))local nu=math.deg(lj(constructRight,constructVelocity,constructForward))local bS=worldVertical*-1;stalling=inAtmo and nt<-YawStallAngle or nt>YawStallAngle or nu<-PitchStallAngle or nu>PitchStallAngle;local nw=a.getMouseDeltaX()local nx=a.getMouseDeltaY()if lb then local ny=f()-lb;nw=nw*ny/0.016;nx=nx*ny/0.016 end;lb=f()if InvertMouse and not holdingShift then nx=-nx end;kT=0;kU=0;kS=0;local nz=j.getWorldPosition()planet=sys:closestBody(nz)kepPlanet=Kep(planet)orbit=kepPlanet:orbitalParameters(nz,constructVelocity)nearPlanet=c.getClosestPlanetInfluence()>0 or coreAltitude>0 and coreAltitude<200000;local k8=planet:getGravity(nz):len()*coreMass;kV=0;local nA=j.getMaxThrustAlongAxis("ground",j.getOrientationUp())[1]if not l1 then if d_()and holdingShift then if not Animating then simulatedX=o(simulatedX+nw/2,-ResolutionX/2,ResolutionX/2)simulatedY=o(simulatedY+nx/2,-ResolutionY/2,ResolutionY/2)end else simulatedX=0;simulatedY=0 end else simulatedX=o(simulatedX+nw/2,-ResolutionX/2,ResolutionX/2)simulatedY=o(simulatedY+nx/2,-ResolutionY/2,ResolutionY/2)mouseDistance=r(simulatedX*simulatedX+simulatedY*simulatedY)if not holdingShift and not d_()then local fh,fi=1,1;if SelectedTab=="SCOPE"then fh,fi=scopeFOV/90,scopeFOV/90 end;if userControlScheme=="virtual joystick"then if mouseDistance>DeadZone then kT=kT-o(aV(simulatedX)-DeadZone,0,ResolutionX/2)*utils.sign(simulatedX)*MouseXSensitivity*fh;kS=kS-o(aV(simulatedY)-DeadZone,0,ResolutionY/2)*utils.sign(simulatedY)*MouseYSensitivity*fi end else simulatedX=0;simulatedY=0;if userControlScheme=="mouse"then kS=(-utils.smoothstep(nx,-100,100)+0.5)*2*mV;kT=(-utils.smoothstep(nw,-100,100)+0.5)*2*mW end end end end;local nB=velMag>27777;if velMag>SpaceSpeedLimit/3.6 and not inAtmo and not Autopilot and not nB then k("Space Speed Engine Shutoff reached")AP.cmdThrottle(0)end;if not nB and LastIsWarping then AP.clearAll()if not BrakeIsOn then AP.BrakeToggle()end;AP.cmdThrottle(0)end;LastIsWarping=nB;if atmosDensity>0.09 then if velMag>adjustedAtmoSpeedLimit/3.6 and not AtmoSpeedAssist and not kA then BrakeIsOn="SpdLmt"kA=true elseif not AtmoSpeedAssist and kA then if velMag<adjustedAtmoSpeedLimit/3.6 then BrakeIsOn=false;kA=false end end end;if ProgradeIsOn then if spaceLand then BrakeIsOn=false;local nC,cj=false,CustomTarget;if not cj then cj=vec3(constructVelocity)end;nC=lB(CustomTarget.position-worldPos,0.1)autoRoll=true;if nC then AP.cmdCruise(g(adjustedAtmoSpeedLimit))if(aV(adjustedRoll)<2 or aV(adjustedPitch)>85)and velMag>=adjustedAtmoSpeedLimit/3.6-1 then BrakeIsOn=false;ProgradeIsOn=false;if spaceLand~=2 then kR=true end;if spaceLand==true then finalLand=true end;spaceLand=false;Autopilot=false;AP.BeginReentry()end elseif inAtmo and AtmoSpeedAssist then AP.cmdThrottle(1)end elseif velMag>ej then lB(vec3(constructVelocity),0.01)end end;if RetrogradeIsOn then if inAtmo then RetrogradeIsOn=false elseif velMag>ej then lB(-vec3(constructVelocity))end end;if not ProgradeIsOn and spaceLand and not IntoOrbit then if not inAtmo then if spaceLand~=2 then kR=true end;AP.BeginReentry()spaceLand=false;finalLand=true else spaceLand=false;if not l8 then l8=true end end end;if finalLand and CustomTarget and(aV(coreAltitude-HoldAltitude)<500 or atmosDensity>=0.11)and(CustomTarget.position-worldPos):len()-aV(coreAltitude-autopilotTargetPlanet:getAltitude(CustomTarget.position))>3000 then if not l8 then l8=true end;finalLand=false end;if VertTakeOff then autoRoll=true;local nD=HoldAltitude;if vSpd<-30 then k("Unable to achieve lift. Safety Landing.")upAmount=0;autoRoll=autoRollPreference;VertTakeOff=false;BrakeLanding=true elseif not ExternalAGG and antigravOn or HoldAltitude<planet.spaceEngineMinAltitude then if antigravOn then nD=antigrav.getBaseAltitude()end;if coreAltitude<nD-200 then kW=0;upAmount=0.35;BrakeIsOn=false elseif vSpd>0 then BrakeIsOn="VTO Limit"upAmount=0 elseif vSpd<-30 then BrakeIsOn="VTO Fall"upAmount=1 elseif coreAltitude>=nD then if antigravOn then if Autopilot or VectorToTarget then AP.ToggleVerticalTakeoff()else BrakeIsOn="VTO Complete"VertTakeOff=false end;k("Takeoff complete. Singularity engaged")bE("aggLk","AG")else BrakeIsOn=false;k("VTO complete. Engaging Horizontal Flight")bE("vtoc","VT")AP.ToggleVerticalTakeoff()end;upAmount=0 end else if atmosDensity>0.08 then kW=0;BrakeIsOn=false;upAmount=0.8 elseif atmosDensity<0.08 and inAtmo then BrakeIsOn=false;if SpaceEngineVertDn then kW=0;upAmount=0.8 else upAmount=0;kW=36;AP.cmdCruise(3500)end else autoRoll=autoRollPreference;IntoOrbit=true;OrbitAchieved=false;CancelIntoOrbit=false;kJ=false;kH=nil;kI=nil;if kM==nil then kM=planet end;OrbitTargetOrbit=nD;kL=true;VertTakeOff=false end end;if kW~=nil then local nE=o(kW-adjustedPitch,-PitchStallAngle*0.80,PitchStallAngle*0.80)n0:inject(nE)local nF=o(n0:get(),-1,1)kS=nF end end;if alignTarget then local cj=alignTarget*(AutopilotTargetCoords-worldPos)lB(cj,0.1)end;if IntoOrbit then local function nG()if not orbit.apoapsis or not orbit.periapsis then return false end;if orbit.periapsis.altitude>=OrbitTargetOrbit*0.99 and orbit.apoapsis.altitude>=OrbitTargetOrbit*0.99 and orbit.periapsis.altitude<orbit.apoapsis.altitude and orbit.periapsis.altitude*1.05>=orbit.apoapsis.altitude and aV(OrbitTargetOrbit-coreAltitude)<1000 then return true else return false end end;local lI;local nH=false;local nI=e4(OrbitTargetOrbit,4)if kM==nil then kM=planet;if VectorToTarget then kM=autopilotTargetPlanet end end;if not kL then OrbitTargetOrbit=g(kM.radius+kM.surfaceMaxAltitude+LowOrbitHeight)if kM.hasAtmosphere then OrbitTargetOrbit=g(kM.radius+kM.noAtmosphericDensityAltitude+LowOrbitHeight)end;kL=true end;if kX.VectorToTarget and CustomTarget then lI=CustomTarget.position-worldPos end;local nJ,nK=Kep(kM):escapeAndOrbitalSpeed((worldPos-kM.center):len()-kM.radius)nK=nK*3.6+1+(MaintainOrbit and FastOrbit*nK*3.6 or 0)local nL=adjustedRoll;if not kJ then local nM=false;local nN=false;if PlayerThrottle>0 then AP.cmdThrottle(0)end;kI=0;orbitMsg="Aligning to orbital path - OrbitHeight: "..nI;if kX.VectorToTarget then lB(lI:normalize():project_on_plane(worldVertical))nH=constructForward:dot(lI:project_on_plane(kY):normalize())>0.95 else lB(constructVelocity)nH=nt<0.5;if velMag<150 then nH=true end end;kS=0;kH=0;if adjustedPitch<=kH+2 and adjustedPitch>=kH-2 then nM=true else nM=false end;if nL<=kI+2 and nL>=kI-2 then nN=true else nN=false end;if nM and nN and nH then kH=nil;kI=nil;kJ=true end else if coreAltitude<OrbitTargetOrbit*1.5 then if kX.VectorToTarget then lB(lI:normalize():project_on_plane(worldVertical))elseif velMag>150 then lB(constructVelocity)end end;kS=0;if kX.VectorToTarget and CustomTarget then local brakeDistance,_=Kinematic.computeDistanceAndTime(velMag,adjustedAtmoSpeedLimit/3.6,coreMass,0,0,LastMaxBrake)if OrbitAchieved and lI:len()>15000+brakeDistance+coreAltitude then orbitMsg="Orbiting to Target"if coreAltitude-100<=kM.noAtmosphericDensityAltitude or travelTime>orbit.timeToPeriapsis and orbit.periapsis.altitude<kM.noAtmosphericDensityAltitude or not nG()and orbit.eccentricity>0.1 then k("Re-Aligning Orbit")OrbitAchieved=false end elseif OrbitAchieved or lI:len()<15000+brakeDistance+coreAltitude then k("Orbit complete, proceeding with reentry")bE("orCom","OB")AutopilotTargetCoords=CustomTarget.position;kR=true;finalLand=true;kX.VectorToTarget,kX.AutopilotAlign=false,false;AP.ToggleIntoOrbit()AP.BeginReentry()return end end;if kK or orbit.periapsis~=nil and orbit.apoapsis~=nil and orbit.eccentricity<1 and coreAltitude>OrbitTargetOrbit*0.9 and coreAltitude<OrbitTargetOrbit*1.4 then if orbit.apoapsis~=nil or kK then if(nG()or OrbitAchieved)and not MaintainOrbit then if OrbitAchieved then BrakeIsOn=false;if not throttleMode or PlayerThrottle>0 then AP.cmdThrottle(0)end;kH=0;if not kX.VectorToTarget then k("Orbit complete")bE("orCom","OB")AP.ToggleIntoOrbit()end else kN=kN+1;if kN>=2 then OrbitAchieved=true end end else if nG()then orbitMsg="Maintaining "kK=false else orbitMsg="Adjusting "kK=true;AP.cmdCruise(nK)local nO=OrbitTargetOrbit-coreAltitude;mY:inject(nO-vSpd*o(utils.smoothstep(2000-nO,-2000,2000)^6*10,1,10))kH=o(mY:get(),-75,75)end;orbitMsg=orbitMsg.." - OrbitHeight: "..nI end end else local nP=2.75;local nQ=aV(bF(nJ*nP))local i_=nQ%50;if i_>0 then nQ=nQ-i_+50 end;BrakeIsOn=false;if coreAltitude<OrbitTargetOrbit*0.8 then orbitMsg="Escaping planet gravity - OrbitHeight: "..nI;kH=utils.map(vSpd,200,0,-15,80)elseif coreAltitude>=OrbitTargetOrbit*0.8 and coreAltitude<OrbitTargetOrbit*1.15 then orbitMsg="Approaching orbital corridor - OrbitHeight: "..nI;nQ=nQ*0.75;kH=utils.map(vSpd,100,-100,-15,65)elseif coreAltitude>=OrbitTargetOrbit*1.15 and coreAltitude<OrbitTargetOrbit*1.5 then orbitMsg="Approaching orbital corridor - OrbitHeight: "..nI;nQ=nQ*0.75;if vSpd<0 or kK then kH=utils.map(coreAltitude,OrbitTargetOrbit*1.5,OrbitTargetOrbit*1.01,-30,60)else kH=utils.map(coreAltitude,OrbitTargetOrbit*0.99,OrbitTargetOrbit*1.5,0,-30)end elseif coreAltitude>OrbitTargetOrbit*1.5 then orbitMsg="Reentering orbital corridor - OrbitHeight: "..nI;kH=-65;local nR=utils.map(vSpd,-150,-400,1,0.15)nQ=nQ*nR end;AP.cmdCruise(nQ)end end;if kH~=nil then local nS=kH-adjustedPitch;mZ:inject(nS)local nT=o(mZ:get(),-0.5,0.5)kS=nT end end;if Autopilot and not inAtmo and not spaceLand then local function nU(nV,orbit)a.print(nV)ProgradeIsOn=false;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"AP.cmdThrottle(0)kQ=false;k(nV)bE("apCom","AP")if orbit or spaceLand then if orbit and AutopilotTargetOrbit~=nil and not spaceLand then if not coreAltitude or coreAltitude==0 then return end;OrbitTargetOrbit=coreAltitude;kL=true;AP.ToggleIntoOrbit(autopilotTargetPlanet)elseif spaceLand then spaceLand=false;l8=true end end end;local nW,nX=AutopilotTargetCoords,false;if CustomTarget and CustomTarget.planetname~="Space"then AutopilotRealigned=true;if not TargetSet then local nq=(CustomTarget.position-autopilotTargetPlanet.center):normalize()local nr=nq:project_on_plane((autopilotTargetPlanet.center-worldPos):normalize()):normalize()local nY=autopilotTargetPlanet.center+nr*(autopilotTargetPlanet.radius+AutopilotTargetOrbit)local nZ=CustomTarget.position+(CustomTarget.position-autopilotTargetPlanet.center):normalize()*(AutopilotTargetOrbit-autopilotTargetPlanet:getAltitude(CustomTarget.position))if(worldPos-nY):len()<(worldPos-nZ):len()then nW=nY else nW=nZ;AutopilotEndSpeed=0 end;AutopilotTargetCoords=nW;local n_,o0=AP.checkLOS((AutopilotTargetCoords-worldPos):normalize())if n_ and o0<(worldPos-AutopilotTargetCoords):len()then AutopilotTargetCoords=np()end;AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)nX=true;TargetSet=true end elseif CustomTarget and CustomTarget.planetname=="Space"then if not TargetSet then nX=true;AutopilotRealigned=true;TargetSet=true;nW=CustomTarget.position+(worldPos-CustomTarget.position):normalize()*AutopilotSpaceDistance;AutopilotTargetCoords=nW end elseif CustomTarget==nil then if not TargetSet then nW=np()AutopilotTargetCoords=nW;TargetSet=true;nX=true;AutopilotRealigned=true;AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)end end;AutopilotDistance=(vec3(nW)-worldPos):len()local fO,fP=AP.checkLOS(constructVelocity:normalize())if fP~=nil and fP<AutopilotDistance and fO.name==autopilotTargetPlanet.name then AutopilotDistance=fP end;local nC=true;local o1=(autopilotTargetPlanet.center-(worldPos+vec3(constructVelocity):normalize()*AutopilotDistance)):len()-autopilotTargetPlanet.radius;local fL=e4(o1)l5=widgetTrajectoryAltitudeText;l6='{"label": "Projected Altitude", "value": "'..fL..'"}'if velMag>50 and AutopilotAccelerating then local lI=vec3(nW)-worldPos;local o2=o(math.deg(lj(kY,constructVelocity:normalize(),lI:normalize()))*velMag/500,-90,90)local o3=o(math.deg(lj(constructRight,constructVelocity:normalize(),lI:normalize()))*velMag/500,-90,90)if aV(o2)<20 and aV(o3)<20 then o2=o2*2;o3=o3*2 end;if aV(o2)<2 and aV(o3)<2 then o2=o2*2;o3=o3*2 end;local nt=-math.deg(lj(kY,constructForward,constructVelocity:normalize()))local nu=-math.deg(lj(constructRight,constructForward,constructVelocity:normalize()))n1:inject(o3-nu)local o4=o(n1:get(),-1,1)kS=kS+o4;n2:inject(o2-nt)local o5=o(n2:get(),-1,1)kT=kT+o5;nX=true;if aV(o2)>2 or aV(o3)>2 then if AutopilotStatus~="Adjusting Trajectory"then AutopilotStatus="Adjusting Trajectory"bE("apAdj","AP")end else if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bE("apAcc","AP")end end elseif AutopilotAccelerating and velMag<=50 then lB((nW-worldPos):normalize())end;if o1<AutopilotTargetOrbit*1.5 then AutopilotEndSpeed=adjustedAtmoSpeedLimit/3.6;if CustomTarget==nil then _,AutopilotEndSpeed=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed(o1)end end;local brakeDistance,brakeTime;if not TurnBurn then brakeDistance,brakeTime=lf(velMag)else brakeDistance,brakeTime=li(velMag)end;if Autopilot and not AutopilotAccelerating and not AutopilotCruising and not AutopilotBraking then local fO,fP=AP.checkLOS((AutopilotTargetCoords-worldPos):normalize())if fO then local o6=fO.name;if autopilotTargetPlanet.name~=planet.name then if autopilotTargetPlanet.name~=o6 and fP<AutopilotDistance then collisionAlertStatus="Attempting to clear LOS between "..o6 .." and waypoint."AutopilotTargetCoords=np()l2=true end end else l2=false;collisionAlertStatus=false end end;if not l2 then if not AutopilotCruising and not AutopilotBraking and not nX then nC=lB((nW-worldPos):normalize())elseif TurnBurn and(AutopilotBraking or AutopilotCruising)then nC=lB(-vec3(constructVelocity):normalize())end end;if AutopilotAccelerating then if not kQ then BrakeIsOn=false;AP.cmdThrottle(AutopilotInterplanetaryThrottle)PlayerThrottle=bF(AutopilotInterplanetaryThrottle,2)kQ=true end;local m7=AtmoSpeedAssist and PlayerThrottle or ld;local o7=99999;local kj=-vec3(j.getWorldAcceleration()):dot(constructVelocity:normalize())local o8=o(constructVelocity:dot((nW-worldPos):normalize()),0,velMag)if o8>0 or kj>0 then o7=Kinematic.computeTravelTime(o8,kj,AutopilotDistance-brakeDistance)end;if adjMaxGameVelocity>MaxSpeed or MaxGameVelocity==-1 and adjMaxGameVelocity<MaxSpeed then adjMaxGameVelocity=MaxSpeed-0.2 end;if coreVelocity:len()>=adjMaxGameVelocity or m7==0 and kQ or warmup/4>o7 then AutopilotAccelerating=false;if AutopilotStatus~="Cruising"then bE("apCru","AP")AutopilotStatus="Cruising"end;AutopilotCruising=true;AP.cmdThrottle(0)end;local o9=AutopilotDistance;if o9<=brakeDistance or PreventPvP and pvpDist<=brakeDistance+10000 and notPvPZone then if PreventPvP and pvpDist<=brakeDistance+10000 and notPvPZone and not nB then if pvpDist<kB and pvpDist>2000 then AP.clearAll()k("Autopilot cancelled to prevent crossing PvP Line")BrakeIsOn="PvP Prevent"kB=pvpDist else kB=pvpDist;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bE("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;if not TurnBurn then ProgradeIsOn=true;autoRoll=true end;AP.cmdThrottle(0)kQ=false end elseif AutopilotBraking then if AutopilotStatus~="Orbiting to Target"then BrakeIsOn="AP Brk"end;if TurnBurn then AP.cmdThrottle(1,true)end;local _,nK=Kep(autopilotTargetPlanet):escapeAndOrbitalSpeed((worldPos-autopilotTargetPlanet.center):len()-autopilotTargetPlanet.radius)local lI;if CustomTarget then lI=CustomTarget.position-worldPos end;if CustomTarget and CustomTarget.planetname=="Space"and(velMag<50 or velMag<555 and#apRoute>0)then if#apRoute>0 then if not l8 then table.remove(apRoute,1)end;if#apRoute>0 then BrakeIsOn=false;if not l8 then l8=2 end;return end end;nU("Autopilot complete, arrived at space location")BrakeIsOn="Space Arrival"elseif CustomTarget and CustomTarget.planetname~="Space"and velMag<=nK and(orbit.apoapsis==nil or orbit.periapsis==nil or orbit.apoapsis.altitude<=0 or orbit.periapsis.altitude<=0)then AutopilotTargetCoords=CustomTarget.position;spaceLand=true;nU("Autopilot complete, commencing reentry")AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords)elseif(CustomTarget and CustomTarget.planetname~="Space"or CustomTarget==nil)and orbit.periapsis~=nil and orbit.periapsis.altitude>0 and orbit.eccentricity<1 or AutopilotStatus=="Circularizing"then if AutopilotStatus~="Circularizing"then bE("apCir","AP")AutopilotStatus="Circularizing"end;if velMag<=nK then if CustomTarget then AutopilotTargetCoords=CustomTarget.position;AP.showWayPoint(autopilotTargetPlanet,CustomTarget.position)WaypointSet=false;spaceLand=true;nU("Autopilot complete, establishing low orbit")else nU("Autopilot completed, setting orbit",true)BrakeIsOn=false end end elseif AutopilotStatus=="Circularizing"then nU("Autopilot complete, fixing Orbit",true)end elseif AutopilotCruising then local o9=AutopilotDistance;if o9<=brakeDistance or PreventPvP and pvpDist<=brakeDistance+10000 and notPvPZone then if PreventPvP and pvpDist<=brakeDistance+10000 and notPvPZone then if pvpDist<kB and pvpDist>2000 then if not l8 then l8=true end;k("Autopilot cancelled to prevent crossing PvP Line")BrakeIsOn="Prevent PvP"kB=pvpDist else kB=pvpDist;return end end;AutopilotAccelerating=false;if AutopilotStatus~="Braking"then bE("apBrk","AP")AutopilotStatus="Braking"end;AutopilotBraking=true;if not TurnBurn then ProgradeIsOn=true;autoRoll=true end end;local m7=AtmoSpeedAssist and PlayerThrottle or ld;if m7>0 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bE("apAcc","AP")end;AutopilotCruising=false end else if nC then if not AutopilotRealigned and CustomTarget==nil or not AutopilotRealigned and CustomTarget and CustomTarget.planetname~="Space"then if not spaceLand then AutopilotTargetCoords=vec3(autopilotTargetPlanet.center)+(AutopilotTargetOrbit+autopilotTargetPlanet.radius)*constructRight;AutopilotShipUp=kY;AutopilotShipRight=constructRight end;AutopilotRealigned=true elseif nC and not l2 then AutopilotAccelerating=true;if AutopilotStatus~="Accelerating"then AutopilotStatus="Accelerating"bE("apAcc","AP")end;if not kQ then AP.cmdThrottle(AutopilotInterplanetaryThrottle,true)PlayerThrottle=bF(AutopilotInterplanetaryThrottle,2)kQ=true;BrakeIsOn=false end end end end elseif Autopilot and(CustomTarget~=nil and CustomTarget.planetname~="Space"and inAtmo)then k("Autopilot complete, starting reentry")bE("apCom","AP")AutopilotTargetCoords=CustomTarget.position;BrakeIsOn=false;AutopilotBraking=false;Autopilot=false;TargetSet=false;AutopilotStatus="Aligning"AP.cmdThrottle(0)kQ=false;ProgradeIsOn=true;spaceLand=true;AP.showWayPoint(autopilotTargetPlanet,CustomTarget.position)end;if followMode then autoRoll=true;local o3=0;local bg=vec3(DUPlayer.getWorldPosition())local oa=bg-worldPos;local ob=vec3(oa):project_on(constructForward):len()local oc=vec3(oa):project_on(constructRight):len()local distance=r(ob*ob+oc*oc)lB(oa:normalize())local gA=40;local od=distance<gA;local oe=100;local my=o((distance-gA)/2,10,oe)kS=0;local nC=aV(kT)<0.1;if nC and velMag<my and not od then BrakeIsOn=false;o3=-20 else BrakeIsOn="Follow"o3=0 end;local of=0;if aV(o3-adjustedPitch)>of then n3:inject(o3-adjustedPitch)local o4=n3:get()kS=o4 end end;if AltitudeHold or BrakeLanding or Reentry or VectorToTarget or LockPitch~=nil then local og=LastMaxBrakeInAtmo;if og then og=og*o(velMag/100,0.1,1)*atmosDensity else og=LastMaxBrake end;if not inAtmo then og=LastMaxBrake end;k_=constructForward:project_on_plane(worldVertical):normalize():dot(constructVelocity)if k_>100 then brakeDistance,brakeTime=Kinematic.computeDistanceAndTime(k_,100,coreMass,0,0,og)local oh,_=Kinematic.computeDistanceAndTime(100,0,coreMass,0,0,og*0.55)brakeDistance=brakeDistance+oh else brakeDistance,brakeTime=Kinematic.computeDistanceAndTime(k_,0,coreMass,0,0,og*0.55)end;local nO=HoldAltitude-coreAltitude-vSpd;local oi=200+velMag;if Reentry or spaceLand then minMax=2000+velMag end;local oj=1;if AutoTakeoff then oj=o(velMag/100,0.1,1)end;local o3=(utils.smoothstep(nO,-oi,oi)-0.5)*2*MaxPitch*oj;if not Reentry and not spaceLand and not VectorToTarget and constructForward:dot(constructVelocity:normalize())<0.99 then o3=(utils.smoothstep(nO,-oi*o(20-19*atmosDensity*10,1,20),oi*o(20-19*atmosDensity*10,1,20))-0.5)*2*MaxPitch*o(2-atmosDensity*10,1,2)*oj end;if not AltitudeHold then o3=0 end;if LockPitch~=nil then if nearPlanet and not IntoOrbit then o3=LockPitch else LockPitch=nil end end;autoRoll=true;local ok=kS;if Reentry then local ol=g(adjustedAtmoSpeedLimit)local om,on=Kinematic.computeDistanceAndTime(velMag,ol/3.6,coreMass,0,0,LastMaxBrake-planet.gravity*9.8*coreMass)om=om==-1 and 5000 or om;local oo=coreAltitude-(planet.noAtmosphericDensityAltitude+om)local op=coreAltitude>planet.noAtmosphericDensityAltitude+om*1.35;if op then o3=ReEntryPitch;if velMag<=ol/3.6 and velMag>ol/3.6-10 and aV(constructVelocity:normalize():dot(constructForward))>0.9 and not throttleMode then WasInCruise=false;AP.cmdThrottle(1)end elseif(throttleMode or e0:getTargetSpeed(axisCommandId.longitudinal)~=ol)and not op and not inAtmo then AP.cmdCruise(ol)end;if throttleMode then if velMag>ol/3.6 and not op then BrakeIsOn="Reentry Limit"if PlayerThrottle>0 then AP.cmdThrottle(0)end else BrakeIsOn=false end else BrakeIsOn=false end;if vSpd>0 then BrakeIsOn="Reentry vSpd"end;if not kR then o3=-80;if coreAltitude<planet.surfaceMaxAltitude+(planet.atmosphereThickness-planet.surfaceMaxAltitude)*0.25 then k("PARACHUTE DEPLOYED at "..bF(coreAltitude,0))Reentry=false;BrakeLanding=true;StrongBrakes=true;AP.cmdThrottle(0)o3=0;autoRoll=autoRollPreference end elseif planet.noAtmosphericDensityAltitude>0 and op then autoRoll=true elseif not op then if not inAtmo and(throttleMode or e0:getTargetSpeed(axisCommandId.longitudinal)~=ol)then AP.cmdCruise(ol)end;if velMag<ol/3.6+1 then BrakeIsOn=false;kR=false;Reentry=false;autoRoll=true;AP.cmdThrottle(1)end end end;if velMag>ej and not spaceLaunch and not VectorToTarget and not BrakeLanding and ForceAlignment then lB(vec3(constructVelocity))end;if ReversalIsOn or(VectorToTarget or spaceLaunch)and AutopilotTargetIndex>0 and inAtmo then local lI;if ReversalIsOn then if type(ReversalIsOn)=="table"then lI=ReversalIsOn elseif ReversalIsOn<3 and ReversalIsOn>0 then lI=-worldVertical:cross(constructVelocity)*5000 elseif ReversalIsOn>=3 then lI=worldVertical:cross(constructVelocity)*5000 elseif ReversalIsOn<0 then lI=constructVelocity*25000 end elseif CustomTarget~=nil then lI=CustomTarget.position-worldPos else lI=autopilotTargetPlanet.center-worldPos end;local o2=math.deg(lj(worldVertical:normalize(),constructVelocity,lI))*2;local gD=math.rad(aV(adjustedRoll))if velMag>minRollVelocity and inAtmo then local oq=1000+velMag;local os=(utils.smoothstep(nO-vSpd*10,-oq,oq)-0.5)*2*MaxPitch;local ot=o(90-os,0,180)kV=o(o2*2,-ot,ot)local ou=o2;o2=o(o(o2,-YawStallAngle*0.80,YawStallAngle*0.80)*math.cos(gD)+4*(adjustedPitch-o3)*math.sin(math.rad(adjustedRoll)),-YawStallAngle*0.80,YawStallAngle*0.80)local ov=1;if kV~=0 then ov=aV(gD/kV)end;ov=(90-o(aV(kV-adjustedRoll),0,90))/90;local ow=o3;if aV(adjustedRoll)>90 then ow=-ow end;o3=ov*o(o(ow*math.cos(gD),-PitchStallAngle*0.8,PitchStallAngle*0.8)+aV(o(aV(ou)*math.sin(gD),-PitchStallAngle*0.80,PitchStallAngle*0.80)),-PitchStallAngle*0.80,PitchStallAngle*0.80)else kV=0;o2=o(o2,-YawStallAngle*0.80,YawStallAngle*0.80)end;local ox=nt-o2;if ReversalIsOn and aV(ox)<=0.0001 and(type(ReversalIsOn)=="table"or type(ReversalIsOn)~="table"and ReversalIsOn<0 and aV(adjustedRoll)<1)then if ReversalIsOn==-2 then AP.ToggleAltitudeHold()end;ReversalIsOn=nil;bE("180Off","BR")return end;if not stalling and velMag>minRollVelocity and inAtmo then n4:inject(ox)local o5=o(n4:get(),-1,1)kT=kT+o5 elseif inAtmo and abvGndDet>-1 or velMag<minRollVelocity then lB(lI)elseif stalling and inAtmo then if(nt<-YawStallAngle or nt>YawStallAngle)and inAtmo then lB(constructVelocity)end;if(nu<-PitchStallAngle or nu>PitchStallAngle)and inAtmo then o3=o(adjustedPitch-nu,adjustedPitch-PitchStallAngle*0.80,adjustedPitch+PitchStallAngle*0.80)end end;if CustomTarget~=nil and not spaceLaunch then local nD=planet:getAltitude(CustomTarget.position)local oo=lI:project_on_plane(worldVertical):len()StrongBrakes=true;if HoldAltitude<planet.noAtmosphericDensityAltitude and not spaceLaunch and not AutoTakeoff and not Reentry and(oo<=brakeDistance and lI:len()<planet.radius)and(constructVelocity:project_on_plane(worldVertical):normalize():dot(lI:project_on_plane(worldVertical):normalize())>0.99 or VectorStatus=="Finalizing Approach")then VectorStatus="Finalizing Approach"if#apRoute>0 then if not l8 then table.remove(apRoute,1)end;if#apRoute>0 then if not l8 then l8=2 end;return end end;if not throttleMode or PlayerThrottle>0 then AP.cmdThrottle(0)end;if AltitudeHold then AP.ToggleAltitudeHold()VectorToTarget=true end;BrakeIsOn="AP Finalizing"elseif not AutoTakeoff then BrakeIsOn=false end;if VectorStatus=="Finalizing Approach"and(k_<0.1 or oo<0.1 or LastDistanceToTarget~=nil and LastDistanceToTarget<oo)then bE("bklOn","BL")BrakeLanding=true;apBrk=true;if CustomTarget.heading then alignHeading=CustomTarget.heading else alignHeading=nil end;VectorToTarget=false;VectorStatus="Proceeding to Waypoint"collisionAlertStatus=false end;LastDistanceToTarget=oo end elseif VectorToTarget and not inAtmo and HoldAltitude>planet.noAtmosphericDensityAltitude and not(spaceLaunch or Reentry)then if CustomTarget~=nil and autopilotTargetPlanet.name==planet.name then local lI=CustomTarget.position-worldPos;local nD=planet:getAltitude(CustomTarget.position)local oo=r(lI:len()^2-(coreAltitude-nD)^2)local og=LastMaxBrakeInAtmo;if og then brakeDistance,brakeTime=Kinematic.computeDistanceAndTime(velMag,0,coreMass,0,0,og/2)StrongBrakes=true;if oo<=brakeDistance+velMag*ns/2 and constructVelocity:project_on_plane(worldVertical):normalize():dot(lI:project_on_plane(worldVertical):normalize())>0.99 then if planet.hasAtmosphere then BrakeIsOn=false;ProgradeIsOn=false;kR=true;spaceLand=false;finalLand=true;Autopilot=false;AP.BeginReentry()end end;LastDistanceToTarget=oo end end end;if not inAtmo and abvGndDet==-1 and(AltitudeHold and HoldAltitude>planet.noAtmosphericDensityAltitude)and not(spaceLaunch or IntoOrbit or Reentry)then if not OrbitAchieved and not IntoOrbit then OrbitTargetOrbit=HoldAltitude;kL=true;if VectorToTarget then kX.VectorToTarget=true end;AP.ToggleIntoOrbit()VectorToTarget=false;kJ=true end end;if stalling and inAtmo and abvGndDet==-1 and velMag>minRollVelocity and VectorStatus~="Finalizing Approach"then lB(constructVelocity)o3=o(adjustedPitch-nu,adjustedPitch-PitchStallAngle*0.80,adjustedPitch+PitchStallAngle*0.80)end;kS=ok;local lu=-1;if BrakeLanding then local oy=allowedHorizontalDrift or 0.05;if not l3 then mX=false;if not throttleMode then AP.cmdThrottle(0)end;if abvGndDet==-1 then e0:setTargetGroundAltitude(500)e0:activateGroundEngineAltitudeStabilization(500)end;if not inAtmo then mX=true end;l3=true end;o3=0;local oz=false;local oA=math.abs(k_)if not ExternalAGG and antigravOn then oz=antigrav.getBaseAltitude()if oz<planet.surfaceMaxAltitude and CustomTarget==nil or CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>oz then oz=false end else oz=false end;if alignHeading then if oA<oy then if vSpd>-brakeLandingRate then BrakeIsOn=false else BrakeIsOn="BL Align BLR"end;if lB(alignHeading,0.001)then alignHeading=nil;autoRoll=autoRollPreference else kS=0;autoRoll=true end else BrakeIsOn="BL Align Hzn"end;if oz and aV(coreAltitude-oz)<250 then BrakeIsOn="AGG Align"end else local oB=false;local oC=30;if oA<10 and nA~=nil and nA>0 then local oD=o(atmosDensity,0.4,2)local og=LastMaxBrakeInAtmo*o(velMag/100,0.1,1)*oD;local oE=nA*oD+og-k8;local oF=og/2-k8;local oG=velMag-r(aV(oF/2)*20/(0.5*coreMass))*utils.sign(oF)if oG<0 then oG=0 end;local oH;if velMag>100 then local oI,_=Kinematic.computeDistanceAndTime(velMag,100,coreMass,0,0,og)local oJ,_=Kinematic.computeDistanceAndTime(100,0,coreMass,0,0,r(og))oH=oI+oJ else oH=Kinematic.computeDistanceAndTime(velMag,0,coreMass,0,0,r(og))end;if oH<20 then BrakeIsOn=false else local oK=0;if oG>100 then local oL,_=Kinematic.computeDistanceAndTime(oG,100,coreMass,0,0,oE)local oM,_=Kinematic.computeDistanceAndTime(100,0,coreMass,0,0,nA*oD+r(og)-k8)oK=oL+oM else oK,_=Kinematic.computeDistanceAndTime(oG,0,coreMass,0,0,nA*oD+r(og)-k8)end;oK=(oK+15+velMag*ns)*1.1;local oN=apBrk and CustomTarget~=nil and planet:getAltitude(CustomTarget.position)>0 and CustomTarget.safe;local nD=nil;if oz and oz<coreAltitude then nD=oz elseif oN then nD=planet:getAltitude(CustomTarget.position)+250 elseif coreAltitude>planet.surfaceMaxAltitude then nD=planet.surfaceMaxAltitude end;if collisionTarget then local oO=planet:getAltitude(collisionTarget[1].center)if nD then if oO>nD then nD=oO end else nD=oO end end;if nD~=nil then local oP=coreAltitude-nD;oB=true;if oP<=oK or oK==-1 or oA>oy and apBrk then if nD==planet.surfaceMaxAltitude and vSpd<-brakeLandingRate then BrakeIsOn="BL Stop BLR"elseif oA>oy and apBrk then BrakeIsOn="BL AP Hzn"else BrakeIsOn="BL Stop Dist"end else BrakeIsOn=false end end end end;lu=abvGndDet;if lu>-1 then BrakeIsOn=false;if not oz and not GearExtended then l0=true;e0:setTargetGroundAltitude(LandingGearGroundHeight)end;if(velMag<1 or constructVelocity:normalize():dot(worldVertical)<0)and not alignHeading and lu-3<LandingGearGroundHeight and(stablized or velMag==0)then BrakeLanding=false;AltitudeHold=false;upAmount=0;lR(0,1)BrakeIsOn="BL Complete"autoRoll=autoRollPreference;apBrk=false;l3=false else if vSpd<-5 or oA>oy*10 then lR(0,1)BrakeIsOn="BL Slowing"else BrakeIsOn=false;lR(-1)end end elseif not oB then if StrongBrakes and constructVelocity:normalize():dot(-bS)<0.999 then BrakeIsOn="BL Strong"lB()elseif oA>10 or oA>oy and apBrk then BrakeIsOn="BL hSpd"elseif vSpd<-brakeLandingRate then BrakeIsOn="BL BLR"lR(0,1)else lR(-1)BrakeIsOn=false end end end else l3=false end;if AutoTakeoff or spaceLaunch then local fO,distance,o6;if AutopilotTargetCoords~=nil then fO,distance=AP.checkLOS((AutopilotTargetCoords-worldPos):normalize())if fO~=nil then o6=fO.name;if autopilotTargetPlanet and o6~=autopilotTargetPlanet.name and not inAtmo then collisionAlertStatus="Takeoff LOS blocked by "..o6 .." in "..e4(distance,1)if o6~=planet.name then AutopilotTargetCoords=np()end end end end;if antigravOn and not spaceLaunch then if coreAltitude>=HoldAltitude-50 and velMag>ej then AutoTakeoff=false;if not Autopilot and not VectorToTarget then BrakeIsOn="ATO Agg Arrive"AP.cmdThrottle(0)end end elseif aV(o3)<15 and coreAltitude/HoldAltitude>0.75 then AutoTakeoff=false;if not spaceLaunch then if throttleMode and not AtmoSpeedAssist then d.control.cancelCurrentControlMasterMode()end elseif spaceLaunch and velMag<ej then Autopilot=true;spaceLaunch=false;AltitudeHold=false;AutoTakeoff=false;AP.cmdThrottle(0)elseif spaceLaunch then AP.cmdThrottle(0)BrakeIsOn="ATO Space"end elseif spaceLaunch and not inAtmo and autopilotTargetPlanet~=nil and(fO==nil or o6==autopilotTargetPlanet.name)then Autopilot=true;collisionAlertStatus=false;spaceLaunch=false;AltitudeHold=false;AutoTakeoff=false;if not throttleMode then AP.cmdThrottle(0)end;AutopilotAccelerating=true end end;local oQ=abvGndDet>-1;local oR=adjustedPitch;if(VectorToTarget or spaceLaunch or ReversalIsOn)and not oQ and velMag>minRollVelocity and inAtmo then local gD=math.rad(aV(adjustedRoll))oR=adjustedPitch*aV(math.cos(gD))+nu*math.sin(gD)end;local oS=o(o3-oR,-PitchStallAngle*0.80,PitchStallAngle*0.80)if not inAtmo and VectorToTarget then oS=o(o3-oR,-85,MaxPitch)elseif not inAtmo then oS=o(o3-oR,-MaxPitch,MaxPitch)end;if aV(adjustedRoll)<5 or VectorToTarget or ReversalIsOn or BrakeLanding or oQ or AltitudeHold then n3:inject(oS)local o4=n3:get()kS=kS+o4 end end;if antigrav~=nil and not ExternalAGG then if AntigravTargetAltitude==nil or AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if desiredBaseAltitude~=AntigravTargetAltitude then desiredBaseAltitude=AntigravTargetAltitude;l7=desiredBaseAltitude end end;if(inAtmo or Reentry or finalLand)and AtmoSpeedAssist and throttleMode then local oT=0;if ExtraEscapeThrust>0 and not Reentry and atmosDensity>0.005 and atmosDensity<0.1 and vSpd>-50 then local oU=j.getFrictionBurnSpeed()*ExtraEscapeThrust;local oV=adjustedAtmoSpeedLimit/3.6;if oU>oV then oT=oU-oV-1 end end;n5:inject(adjustedAtmoSpeedLimit/3.6+oT-constructVelocity:dot(constructForward))local oW=n5:get()calculatedThrottle=o(oW,-1,1)if not ThrottleValue then if calculatedThrottle<PlayerThrottle and(atmosDensity>0.005 or Reentry or finalLand)then ThrottleLimited=true;ThrottleValue=o(calculatedThrottle,0.01,1)else ThrottleLimited=false;ThrottleValue=PlayerThrottle end end;n6:inject(constructVelocity:len()-adjustedAtmoSpeedLimit/3.6-oT)local oX=o(n6:get(),0,1)if inAtmo and vSpd<-80 or(atmosDensity>0.005 or Reentry or finalLand)then brakeInput2=oX end;if brakeInput2>0 then if ThrottleLimited and calculatedThrottle==0.01 and not ThrottleValue then ThrottleValue=0 end else calculatedThrottle=o(calculatedThrottle,0.01,1)end;local oY=''local oZ=vec3()local fx=0;if upAmount~=0 then fx=adjustedAtmoSpeedLimit*upAmount end;local o_=mw(axisCommandId.vertical,fx)d:setEngineForceCommand("vertical airfoil , vertical ground ",o_,mT)local p0='thrust analog longitudinal 'if UseExtra=="All"or UseExtra=="Longitude"then p0=p0 ..ExtraLongitudeTags end;local p1=e0:getAxisCommandType(axisCommandId.longitudinal)local p2=e0:composeAxisAccelerationFromThrottle(p0,axisCommandId.longitudinal)if LeftAmount~=0 then fx=adjustedAtmoSpeedLimit*LeftAmount else fx=0 end;local p3=mJ(axisCommandId.lateral,fx)oY=oY..' , '.."lateral airfoil , lateral ground "oZ=oZ+p3;if oZ:len()>constants.epsilon then d:setEngineForceCommand(oY,oZ,mT,'','','',mU)end;d:setEngineForceCommand(p0,p2,mS)local p4='thrust analog vertical fueled 'local p5='thrust analog lateral fueled 'if UseExtra=="All"or UseExtra=="Lateral"then p5=p5 ..ExtraLateralTags end;if UseExtra=="All"or UseExtra=="Vertical"then p4=p4 ..ExtraVerticalTags end;if upAmount~=0 or lN~=0 or BrakeLanding and BrakeIsOn or not GearExtended and not stablized then d:setEngineForceCommand(p4,o_,mS)else d:setEngineForceCommand(p4,vec3(),mS)end;if LeftAmount~=0 or lM~=0 then d:setEngineForceCommand(p5,p3,mS)else d:setEngineForceCommand(p5,vec3(),mS)end;if nd==0 then nd=brakeInput2 end;local p6=-nd*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*nh)d:setEngineForceCommand('brake',p6)else if AtmoSpeedAssist then if not ThrottleValue then ThrottleValue=PlayerThrottle end end;local my=c.getAxisCommandValue(0)if not throttleMode then n6:inject(constructVelocity:len()-my/3.6)local oX=o(n6:get(),0,1)nd=o(nd+oX,0,1)end;local p6=-nd*(brakeSpeedFactor*constructVelocity+brakeFlatFactor*nh)d:setEngineForceCommand('brake',p6)local oY=''local oZ=vec3()local p7=false;local p0='thrust analog longitudinal 'if ExtraLongitudeTags~="none"and(UseExtra=="All"or UseExtra=="Longitude")then p0=p0 ..ExtraLongitudeTags end;local p1=e0:getAxisCommandType(axisCommandId.longitudinal)if p1==axisCommandType.byThrottle then local p2=e0:composeAxisAccelerationFromThrottle(p0,axisCommandId.longitudinal)d:setEngineForceCommand(p0,p2,mS)elseif p1==axisCommandType.byTargetSpeed then local p2=e0:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)oY=oY..' , '..p0;oZ=oZ+p2;if e0:getTargetSpeed(axisCommandId.longitudinal)==0 or e0:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal)<-e0:getTargetSpeedCurrentStep(axisCommandId.longitudinal)*0.5 then p7=true end end;local p5='thrust analog lateral 'if ExtraLateralTags~="none"and(UseExtra=="All"or UseExtra=="Lateral")then p5=p5 ..ExtraLateralTags end;local p8=e0:getAxisCommandType(axisCommandId.lateral)if p8==axisCommandType.byThrottle then local p9=e0:composeAxisAccelerationFromThrottle(p5,axisCommandId.lateral)d:setEngineForceCommand(p5,p9,mS)elseif p8==axisCommandType.byTargetSpeed then local p3=e0:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)oY=oY..' , '..p5;oZ=oZ+p3 end;local p4='thrust analog vertical 'if ExtraVerticalTags~="none"and(UseExtra=="All"or UseExtra=="Vertical")then p4=p4 ..ExtraVerticalTags end;local pa=e0:getAxisCommandType(axisCommandId.vertical)if pa==axisCommandType.byThrottle then local o_=e0:composeAxisAccelerationFromThrottle(p4,axisCommandId.vertical)if upAmount~=0 or lN~=0 or BrakeLanding and BrakeIsOn then d:setEngineForceCommand(p4,o_,mS,'airfoil','ground','',mU)else d:setEngineForceCommand(p4,vec3(),mS)d:setEngineForceCommand('airfoil vertical',o_,mS,'airfoil','','',mU)d:setEngineForceCommand('ground vertical',o_,mS,'ground','','',mU)end elseif pa==axisCommandType.byTargetSpeed then if upAmount<0 or lN<0 then d:setEngineForceCommand('hover',vec3(),mS)end;local pb=e0:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)oY=oY..' , '..p4;oZ=oZ+pb end;if oZ:len()>constants.epsilon then if nd~=0 or p7 or aV(nh:dot(constructForward))<0.5 then oY=oY..', brake'end;d:setEngineForceCommand(oY,oZ,mT,'','','',mU)end end;local pc=torqueFactor*(nl-nk)local pd=vec3(j.getWorldAirFrictionAngularAcceleration())pc=pc-pd;d:setEngineTorqueCommand('torque',pc,mS,'airfoil','','',mU)d:setBoosterCommand('rocket_engine')if isBoosting and not VanillaRockets then local f9=coreVelocity:len()local pe=0.15;if not throttleMode then local pf=e0:getTargetSpeed(axisCommandId.longitudinal)if f9*3.6>pf*(1-pe)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif f9*3.6<pf*(1-pe)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end else local m7=AtmoSpeedAssist and PlayerThrottle*100 or ld;local my=m7/100;if not inAtmo then my=my*adjMaxGameVelocity;if f9>=my*(1-pe)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif f9<my*(1-pe)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end else local ol=g(adjustedAtmoSpeedLimit)my=my*ol/3.6;if f9>=my*(1-pe)and IsRocketOn then IsRocketOn=false;d:toggleBoosters()elseif f9<my*(1-pe)and not IsRocketOn then IsRocketOn=true;d:toggleBoosters()end end end end end;if userAP then for N,A in pairs(userAP)do kz[N]=A end end;abvGndDet=lp()return kz end;local function pg(d,b,c,a,l,vBooster,hover,antigrav,shield,dbHud_2,gyro,screenHud_1,d_,e0,e1,ph,ca,bF,stringmatch,q,o,bE,e3,ky,k,pi,pj)local j=DUConstruct;local pk={}local pl=true;local pm=5;local pn=5;local po=pm;local pp=pn;local pq=time;local pr=time;function pk.landingGear(l0)GearExtended=not GearExtended;if GearExtended then if Autopilot or VectorToTarget or spaceLaunch or IntoOrbit then AP.ResetAutopilots(true)end;LockPitch=nil;AP.cmdThrottle(0)if vBooster or hover then if(inAtmo or coreAltitude<20000)and not l0 and abvGndDet==-1 then bE("bklOn","BL")StrongBrakes=true;Reentry=false;AutoTakeoff=false;VertTakeOff=false;if BrakeLanding then apBrk=not apBrk end;autoRoll=true;GearExtended=false;BrakeLanding=true else if hasGear then bE("grOut","LG",1)d.control.deployLandingGears()end;apBrk=false;if inAtmo then autoRoll=autoRollPreference;BrakeIsOn="Landing"end end;if l0 or abvGndDet~=-1 and abvGndDet>LandingGearGroundHeight-3 or not stablized then BrakeLanding=true end;e0:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)e0:setTargetGroundAltitude(LandingGearGroundHeight)AltitudeHold=false elseif hasGear and not BrakeLanding then bE("grOut","LG",1)d.control.deployLandingGears()end else if BrakeLanding then BrakeLanding=false end;if hasGear then bE("grIn","LG",1)d.control.retractLandingGears()end;e0:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)if stablized then if LandingGearGroundHeight<e0.targetGroundAltitude then e0:setTargetGroundAltitude(e0.targetGroundAltitude)else e0:setTargetGroundAltitude(TargetHoverHeight)end else e0:setTargetGroundAltitude(TargetHoverHeight)end end end;function pk.startControl(ps)local function pt(m3)local m4=1;local function pu(pv,m3)local pw={planet.surfaceMaxAltitude+100,planet.spaceEngineMinAltitude-0.01*planet.noAtmosphericDensityAltitude,planet.noAtmosphericDensityAltitude+LowOrbitHeight,planet.radius*(TargetOrbitRadius-1)+planet.noAtmosphericDensityAltitude}local px=pv;for _,A in ipairs(pw)do if m3 and px>A then pv=A elseif pv<A and not m3 then pv=A;break end end;return pv end;if m3 then m4=-1 end;if not ExternalAGG and antigravOn then if holdingShift and m3 then AntigravTargetAltitude=1000 elseif AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+m4*pn;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end else AntigravTargetAltitude=desiredBaseAltitude+m4*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then if holdingShift then OrbitTargetOrbit=pu(OrbitTargetOrbit,m3)else OrbitTargetOrbit=OrbitTargetOrbit+m4*pm end;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else if holdingShift and inAtmo then HoldAltitude=pu(HoldAltitude,m3)else HoldAltitude=HoldAltitude+m4*pm end end else e0:updateTargetGroundAltitudeFromActionStart(m4*1.0)end end;local function py(pz)if not inAtmo then k("Flight Assist in Atmo only")return end;local x=type(pz)if ReversalIsOn==nil then if x=="table"then if Autopilot or VectorToTarget then AP.ToggleAutopilot()end;bE("180On","BR")elseif pz==1 then bE("bnkLft","BR")else bE("bnkRht","BR")end;if not AltitudeHold and not Autopilot and not VectorToTarget then AP.ToggleAltitudeHold()if x~="table"then pz=pz+1 end end;ReversalIsOn=pz else bE("180Off","BR")ReversalIsOn=nil end end;local function pA()if e1()then simulatedX=0;simulatedY=0;ph(PrevViewLock)elseif d_()and ShiftShowsRemoteButtons then Animated=false;Animating=false end;holdingShift=false end;if ps=="gear"then CONTROL.landingGear()elseif ps=="light"then if AltIsOn then if d_()then if DUPlayer.isFrozen()then DUPlayer.freeze(false)k("Player Unfrozen, pitch/yaw/roll disabled")else DUPlayer.freeze(true)k("Player Frozen, pitch/yaw/roll enabled")end else k("Player Freeze/Unfreeze only used with remote")end;return end;if d.control.isAnyHeadlightSwitchedOn()then d.control.switchOffHeadlights()else d.control.switchOnHeadlights()end elseif ps=="forward"then if AltIsOn and not inAtmo and not Autopilot then ProgradeIsOn=not ProgradeIsOn;RetrogradeIsOn=false else pitchInput=pitchInput-1 end elseif ps=="backward"then if AltIsOn then if not inAtmo then if not Autopilot then RetrogradeIsOn=not RetrogradeIsOn;ProgradeIsOn=false else TurnBurn=not TurnBurn end else py(-constructVelocity*5000)end else pitchInput=pitchInput+1 end elseif ps=="left"then if AltIsOn then py(1)else rollInput=rollInput-1 end elseif ps=="right"then if AltIsOn then py(3)else rollInput=rollInput+1 end elseif ps=="yawright"then yawInput=yawInput-1;alignHeading=nil elseif ps=="yawleft"then yawInput=yawInput+1;alignHeading=nil elseif ps=="straferight"then e0:updateCommandFromActionStart(axisCommandId.lateral,1.0)LeftAmount=1 elseif ps=="strafeleft"then e0:updateCommandFromActionStart(axisCommandId.lateral,-1.0)LeftAmount=-1 elseif ps=="up"then AP.vertical(1)if abvGndDet-3<LandingGearGroundHeight and coreAltitude>0 and GearExtended then CONTROL.landingGear()end elseif ps=="down"then AP.vertical(-1)elseif ps=="groundaltitudeup"then pt()elseif ps=="groundaltitudedown"then pt(true)elseif ps=="option1"then toggleView=false;if AltIsOn and holdingShift then local pB=""for i=1,#passengers do pB=pB.."| Name: "..a.getPlayerName(passengers[i]).." Mass: "..bF(j.getBoardedPlayerMass(passengers[i])/1000,1).."t "end;a.print("Onboard: "..pB)return end;ATLAS.adjustAutopilotTargetIndex()elseif ps=="option2"then toggleView=false;if AltIsOn and holdingShift then for i=1,#passengers do j.forceDeboard(passengers[i])j.forceInterruptVRSession(passengers[i])end;k("Deboarded All Passengers")return end;ATLAS.adjustAutopilotTargetIndex(1)elseif ps=="option3"then toggleView=false;if AltIsOn and holdingShift then local pB=""for i=1,#ships do pB=pB.."| ID: "..ships[i].." Mass: "..bF(j.getDockedConstructMass(ships[i])/1000,1).."t "end;a.print("Docked Ships: "..pB)return end;if hideHudOnToggleWidgets then if showHud then showHud=false else showHud=true end end elseif ps=="option4"then toggleView=false;if AltIsOn and holdingShift then for i=1,#ships do j.forceUndock(ships[i])end;k("Undocked all ships")return end;ReversalIsOn=nil;if not inAtmo and(AutopilotTargetIndex>0 or#apRoute>0)and not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit then AP.cmdThrottle(1)end;AP.ToggleAutopilot()elseif ps=="option5"then toggleView=false;if AltIsOn and holdingShift then alignTarget=false;AP.ToggleLockPitch()return end;if time-pr<1.5 then if alignTarget then alignTarget=-1;k("Retrograde Alignment lock to "..AutopilotTargetName)return end end;pr=time;if alignTarget then alignTarget=false;k("Alignment cancelled")elseif not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit and not Reentry and not finalLand and not AltitudeHold then alignTarget=1;k("Alignment lock to "..AutopilotTargetName)else k("Disengage autopilot before using Alignment Lock")end elseif ps=="option6"then toggleView=false;if AltIsOn and holdingShift then if shield then SHIELD.ventShield()else k("No shield found")end;return end;AP.ToggleAltitudeHold()elseif ps=="option7"then toggleView=false;if AltIsOn and holdingShift then if shield then shield.toggle()return else k("No shield found")return end end;CollisionSystem=not CollisionSystem;if CollisionSystem then k("Collision System Enabled")else k("Collision System Secured")end elseif ps=="option8"then toggleView=false;if AltIsOn and holdingShift then if AutopilotTargetIndex>0 and CustomTarget~=nil then AP.routeWP()else k("Select a saved wp on IPH to add to or remove from route")end;return end;stablized=not stablized;if not stablized then k("DeCoupled Mode - Ground Stabilization off")e0:deactivateGroundEngineAltitudeStabilization()bE("gsOff","GS")else k("Coupled Mode - Ground Stabilization on")e0:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)sEFC=true;bE("gsOn","GS")end elseif ps=="option9"then toggleView=false;if AltIsOn and holdingShift then e0:resetCommand(axisCommandId.longitudinal)e0:resetCommand(axisCommandId.lateral)e0:resetCommand(axisCommandId.vertical)AP.cmdThrottle(0)c.setTimer("tagTick",0.1)elseif gyro~=nil then gyro.toggle()gyroIsOn=gyro.isActive()if gyroIsOn then bE("gyOn","GA")else bE("gyOff","GA")end else k("No gyro found")end elseif ps=="lshift"then if AltIsOn then holdingShift=true end elseif ps=="brake"then if BrakeToggleStatus or AltIsOn then AP.BrakeToggle("Manual")elseif not BrakeIsOn then AP.BrakeToggle("Manual")else BrakeIsOn="Manual"end elseif ps=="lalt"then toggleView=true;AltIsOn=true;if not d_()and not freeLookToggle and userControlScheme=="keyboard"then ph(true)end elseif ps=="booster"then if AltIsOn then if pi then pi.toggle()if pi.isActive()then k("Transponder On")else k("Transponder Off")end else k("No transponder found")end else if VanillaRockets then d:toggleBoosters()elseif not isBoosting then if not IsRocketOn then d:toggleBoosters()IsRocketOn=true end;isBoosting=true else if IsRocketOn then d:toggleBoosters()IsRocketOn=false end;isBoosting=false end end elseif ps=="stopengines"then local function pC()if time-pq<1.5 then bE("clear","CA")AP.clearAll()end end;pC()pq=time;if e0:getAxisCommandType(0)~=axisCommandType.byTargetSpeed then if AltIsOn then if adjustedAtmoSpeedLimit>0 then adjustedAtmoSpeedLimit=0 else adjustedAtmoSpeedLimit=AtmoSpeedLimit end elseif PlayerThrottle~=0 then e0:resetCommand(axisCommandId.longitudinal)AP.cmdThrottle(0)else AP.cmdThrottle(1)end else if e0:getTargetSpeed(axisCommandId.longitudinal)~=0 then e0:resetCommand(axisCommandId.longitudinal)else if inAtmo then AP.cmdCruise(adjustedAtmoSpeedLimit)else AP.cmdCruise(adjMaxGameVelocity*3.6)end end end elseif ps=="speedup"then AP.changeSpd()elseif ps=="speeddown"then AP.changeSpd(true)elseif ps=="antigravity"and not ExternalAGG then if antigrav~=nil then AP.ToggleAntigrav()else k("No antigrav found")end elseif ps=="leftmouse"then leftmouseclick=true;if holdingShift then pA()toggleView=false else holdingShift=true;PrevViewLock=e1()ph(true)end end end;function pk.stopControl(ps)local function pD()if not ExternalAGG and antigravOn then pp=pn end;if AltitudeHold or VertTakeOff or IntoOrbit then po=pm end end;if ps=="forward"then pitchInput=0 elseif ps=="backward"then pitchInput=0 elseif ps=="left"then if ReversalIsOn then if ReversalIsOn==2 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;rollInput=0 elseif ps=="right"then if ReversalIsOn then if ReversalIsOn==4 then ReversalIsOn=-2 else ReversalIsOn=-1 end end;rollInput=0 elseif ps=="yawright"then yawInput=0 elseif ps=="yawleft"then yawInput=0 elseif ps=="straferight"then e0:updateCommandFromActionStop(axisCommandId.lateral,-1.0)LeftAmount=0 elseif ps=="strafeleft"then e0:updateCommandFromActionStop(axisCommandId.lateral,1.0)LeftAmount=0 elseif ps=="up"then AP.vertical(0,-1)elseif ps=="down"then AP.vertical(0,1)elseif ps=="groundaltitudeup"then pD()toggleView=false elseif ps=="groundaltitudedown"then pD()toggleView=false elseif ps=="brake"then if not BrakeToggleStatus and not AltIsOn then if BrakeIsOn then AP.BrakeToggle()else BrakeIsOn=false end end elseif ps=="lalt"then if holdingShift then holdingShift=false end;if not d_()and freeLookToggle then if toggleView then if e1()then ph(false)else ph(true)end else toggleView=true end elseif not d_()and not freeLookToggle and userControlScheme=="keyboard"then ph(false)end;AltIsOn=false end end;function pk.loopControl(ps)local function pE(m3)local m4=1;if m3 then m4=-1 end;if not ExternalAGG and antigravOn then if AntigravTargetAltitude~=nil then AntigravTargetAltitude=AntigravTargetAltitude+m4*pp;if AntigravTargetAltitude<1000 then AntigravTargetAltitude=1000 end;if AltitudeHold and AntigravTargetAltitude<HoldAltitude+10 and AntigravTargetAltitude>HoldAltitude-10 then HoldAltitude=AntigravTargetAltitude end;pp=o(pp*1.05,pn,50)else AntigravTargetAltitude=desiredBaseAltitude+m4*100 end elseif AltitudeHold or VertTakeOff or IntoOrbit then if IntoOrbit then OrbitTargetOrbit=OrbitTargetOrbit+m4*po;if OrbitTargetOrbit<planet.noAtmosphericDensityAltitude then OrbitTargetOrbit=planet.noAtmosphericDensityAltitude end else HoldAltitude=HoldAltitude+m4*po end;po=o(po*1.05,pm,50)else e0:updateTargetGroundAltitudeFromActionLoop(m4*1.0)end end;local function pF(m3)local m4=1;if m3 then m4=-1 end;if not holdingShift then if AtmoSpeedAssist and not AltIsOn then PlayerThrottle=o(PlayerThrottle+m4*speedChangeSmall/100,-1,1)else e0:updateCommandFromActionLoop(axisCommandId.longitudinal,m4*speedChangeSmall)end end end;if ps=="groundaltitudeup"then if not holdingShift then pE()end elseif ps=="groundaltitudedown"then if not holdingShift then pE(true)end elseif ps=="speedup"then pF()elseif ps=="speeddown"then pF(true)end end;function pk.inputTextControl(m2)local function pG(pH,bg,bZ)local function pI(bg)local F=' *([+-]?%d+%.?%d*e?[+-]?%d*)'local G='::pos{'..F..','..F..','..F..','..F..','..F..'}'local V,W,a2,a3,a4=stringmatch(bg,G)if V=="0"and W=="0"then return vec3(q(a2),q(a3),q(a4))end;a3=math.rad(a3)a2=math.rad(a2)local planet=l[q(V)][q(W)]local aR=math.cos(a2)local pJ=vec3(aR*math.cos(a3),aR*math.sin(a3),math.sin(a2))return planet.center+(planet.radius+a4)*pJ end;local position=pI(bg)return ATLAS.AddNewLocation(pH,position,bZ)end;local i;local pK,dR=nil,nil;local pL="Command List:\n/commands \n/setname <newname> - Updates current selected saved position name\n/G VariableName newValue - Updates global variable to new value\n".."/G dump - shows all variables updatable by /G\n/agg <targetheight> - Manually set agg target height\n".."/addlocation SafeZoneCenter ::pos{0,0,13771471,7435803,-128971} - adds a saved location by waypoint, not as accurate as making one at location\n".."/::pos{0,0,13771471,7435803,-128971} - adds a temporary waypoint that is not saved to databank with name 0Temp\n".."/copydatabank - copies dbHud databank to a blank databank\n".."/iphWP - displays current IPH target's ::pos waypoint in lua chat\n".."/resist 0.15, 0.15, 0.15, 0.15 - Sets shield resistance distribution of the floating 60% extra available, usable once per minute\n".."/deletewp - Deletes current selected custom wp\n".."/createPrivate (all) - dumps private lcoations to screen if present to cut and paste to privatelocations.lua, all if present will make it include all databank locations.\n".."/trans (whatever) - shows the current transponder setting, whatever, if present, is the new tag that is set.\n".."/pipecenter - Shows a waypoint to closest pipe center and prints loc in lua chat and sets it to 1-Temp in IPH for use with autopilot"i=string.find(m2," ")pK=m2;if i~=nil and string.find(m2,"::")~=1 then pK=string.sub(m2,0,i-1)dR=string.sub(m2,i+1)end;if pK=="/help"or pK=="/commands"then for fN in string.gmatch(pL,"([^\n]+)")do a.print(fN)end;return elseif pK=="/setname"then if dR==nil or dR==""then k("Usage: ah-setname Newname")return end;if AutopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.UpdatePosition(dR)else k("Select a saved target to rename first")end elseif shield and pK=="/resist"then SHIELD.setResist(dR)elseif pK=="/addlocation"or string.find(m2,"::pos")~=nil then local bZ=false;local pH="0-Temp"if dR==nil or dR==""or pK~="/addlocation"then dR=pK;bZ=true end;if not alignTarget and not Autopilot and not VectorToTarget and not spaceLaunch and not IntoOrbit and not Reentry and not finalLand then i=string.find(dR,"::")if not bZ then pH=string.sub(dR,1,i-2)end;local bg=string.sub(dR,i)bg=bg:gsub("%s+","")pG(pH,bg,bZ)else k("Disengage Autopilot before adding waypoints")end elseif pK=="/agg"then if dR==nil or dR==""then k("Usage: /agg targetheight")return end;dR=q(dR)if dR<1000 then dR=1000 end;AntigravTargetAltitude=dR;k("AGG Target Height set to "..dR)elseif pK=="/G"then if dR==nil or dR==""then k("Usage: /G VariableName variablevalue\n/G dump - shows all variables")return end;if dR=="dump"then for N,A in pairs(e3())do if type(A.get())=="boolean"then if A.get()==true then a.print(N.." true")else a.print(N.." false")end elseif A.get()==nil then a.print(N.." nil")else a.print(N.." "..A.get())end end;return end;i=string.find(dR," ")local pM=string.sub(dR,0,i-1)local pN=string.sub(dR,i+1)for N,A in pairs(e3())do if N==pM then local pO=type(A.get())if pO=="number"then pN=q(pN)if N=="AtmoSpeedLimit"then adjustedAtmoSpeedLimit=pN end end;k("Variable "..pM.." changed to "..pN)if N=="MaxGameVelocity"and pN~=-1 then pN=pN/3.6;if pN>MaxSpeed-0.2 then pN=MaxSpeed-0.2;k("Updated "..pM.." changed to "..bF(pN*3.6,1))end end;if pO=="boolean"then if string.lower(pN)=="true"then pN=true else pN=false end end;A.set(pN)return end end;k("No such global variable: "..pM)elseif pK=="/deletewp"then if AutopilotTargetIndex>0 and CustomTarget~=nil then ATLAS.ClearCurrentPosition()else k("Select a custom wp to delete first in IPH")end elseif pK=="/copydatabank"then if dbHud_2 then ky(true)else k("Spare Databank required to copy databank")end elseif pK=="/iphWP"then if AutopilotTargetIndex>0 then a.print(AP.showWayPoint(autopilotTargetPlanet,AutopilotTargetCoords,true))a.print(json.encode(AutopilotTargetCoords))k("::pos waypoint shown in lua chat in local and world format")else k("No target selected in IPH")end elseif pK=="/trans"then if pi then if dR==nil or dR==""then k("Current tag: "..pj(pi.getTags()))return else pi.setTags({dR})k("Transponder tag set to: "..dR)end else k("No transponder found.")end elseif pK=="/createPrivate"then local pP="privatelocations = {\n"local pQ=""if#privatelocations>0 then for N,A in pairs(privatelocations)do pP=pP.."{position = {x = "..A.position.x..", y = "..A.position.y..", z = "..A.position.z.."},\n ".."name = '"..A.name.."',\n planetname = '"..A.planetname.."',\n gravity = "..A.gravity..",\n"if A.heading then pP=pP.."heading = {x = "..A.heading.x..", y = "..A.heading.y..", z = "..A.heading.z.."},\n"end;if A.safe then pP=pP.."safe = true},\n"else pP=pP.."safe = false},\n"end end end;pQ=#privatelocations.."-Private "if dR=="all"then for N,A in pairs(SavedLocations)do pP=pP.."{position = {x = "..A.position.x..", y = "..A.position.y..", z = "..A.position.z.."},\n ".."name = '*"..A.name.."',\n planetname = '"..A.planetname.."',\n gravity = "..A.gravity..",\n"if A.heading then pP=pP.."heading = {x = "..A.heading.x..", y = "..A.heading.y..", z = "..A.heading.z.."},\n"end;if A.safe then pP=pP.." safe = true},\n"else pP=pP.."safe = false},\n"end end;pQ=pQ..#SavedLocations.."-Public "end;pP=pP.."}\n return privatelocations"if screenHud_1 then screenHud_1.setHTML(pP)end;k(pQ.."locations dumped to screen if present.\n Cut and paste to privatelocations.lua to use")msgTimer=7 elseif pK=="/pipecenter"then if Autopilot then k("Disengage autopilot before using /pipecenter")elseif pipePosC~=nil then local pR=pipePosC;local bg="::pos{0,0,"..pR["x"]..","..pR["y"]..","..pR["z"].."}"pG("1-ClosestPipeCenter",bg,true)if pipePosT then pR=pipePosT;bg="::pos{0,0,"..pR["x"]..","..pR["y"]..","..pR["z"].."}"pG("2-"..pipeDestT.name.."PipeCenter",bg,true)bg=worldPos+pipeDestT.center-pR;bg="::pos{0,0,"..bg["x"]..","..bg["y"]..","..bg["z"].."}"pG("3-"..pipeDestT.name.."PipeParallel",bg,true)end else k("No Pipe Center known")end end end;function pk.tagTick()if UseExtra=="Off"then UseExtra="All"elseif UseExtra=="All"then UseExtra="Longitude"elseif UseExtra=="Longitude"then UseExtra="Lateral"elseif UseExtra=="Lateral"then UseExtra="Vertical"else UseExtra="Off"end;k("Extra Engine Tags: "..UseExtra)c.stopTimer("tagTick")end;if userControl then for N,A in pairs(userControl)do pk[N]=A end end;return pk end;local pS={["34191163"]=130,["590217537"]=170,["590217536"]=220,["590217543"]=290,["3510956948"]=520,["4068567109"]=680,["4068567110"]=880,["4068567111"]=1140,["103319202"]=2080,["801882806"]=2700,["801882807"]=3510,["801882804"]=4560,["681896062"]=16640,["4181605365"]=21632,["4181605362"]=28120,["4181605363"]=36560,["1663412227"]=400,["3126840739"]=800,["2477859329"]=6400,["4180073139"]=50000,["2723679405"]=130,["4270367994"]=170,["4270367989"]=220,["4270367988"]=290,["3660622849"]=520,["3135113517"]=680,["3135113516"]=880,["3135113519"]=1140,["2717114417"]=2080,["3797917193"]=2700,["3797917192"]=3510,["3797917195"]=4560,["1567224122"]=16640,["1298642304"]=21632,["1298642305"]=28120,["1298642310"]=36560,["xs"]=100,["s"]=400,["m"]=1600,["l"]=12800}local pT={["2078334942"]=0.9,["2216300178"]=0.9,["2199218873"]=0.9,["2268129307"]=0.9,["4106743733"]=0.9,["637265250"]=0.9,["3580444026"]=0.9,["319251893"]=0.9,["3464984253"]=0.81,["1104915586"]=0.81,["121825379"]=0.81,["185422505"]=0.81,["4188179628"]=0.81,["55848614"]=0.81,["4169669296"]=0.81,["2010490156"]=0.81,["3464984250"]=0.729,["1104915587"]=0.729,["121825378"]=0.729,["185422504"]=0.729,["4188179631"]=0.729,["55848615"]=0.729,["4169669297"]=0.729,["2010490159"]=0.729,["3464984251"]=0.6561,["1104915584"]=0.6561,["121825381"]=0.6561,["185422511"]=0.6561,["4188179630"]=0.6561,["55848612"]=0.6561,["4169669302"]=0.6561,["2010490158"]=0.6561}function GetFuelTankMaxVolume(pU,dq)return pS[pU..""]or pS[dq..""]or 0 end;function GetFuelTankModifier(pU)return pT[pU..""]or 1 end;function GetFuelTankPrefixes(j0)if j0=="atmo"then return{"Atmospheric ","Uncommon Opt","Advanced Opt","Rare Optimiz","Exotic Optim","Uncommon Gra","Advanced Gra","Rare Gravity","Exotic Gravi"}elseif j0=="space"then return{"Space Fuel T","Uncommon Opt","Advanced Opt","Rare Optimiz","Exotic Optim","Uncommon Gra","Advanced Gra","Rare Gravity","Exotic Gravi"}elseif j0=="rocket"then return{"Rocket Fuel "}end;return{}end;local function pV(d,b,c,l,vBooster,hover,telemeter_1,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,weapon,screenHud_1,pi)local a=DUSystem;local j=DUConstruct;local pW=DUPlayer;local pX=DULibrary;local pY={}local n=string.format;local dY=json.decode;local pj=json.encode;local jJ=b.getElementMaxHitPointsById;local dZ=b.getElementMassById;local d_=d.control.isRemoteControlled;local stringmatch=string.match;local ca=a.destroyWidgetPanel;local bC=a.updateData;local bD=a.addDataToWidget;local ph=a.lockView;local e1=a.isViewLocked;local r=math.sqrt;local q=tonumber;local aV=math.abs;local g=math.floor;local h=c.getAtmosphereDensity;local atan=math.atan;local f=a.getArkTime;local o=utils.clamp;local e0=d.axisCommandManager;local pZ=a.isItemInClass;local p_=a.getItem;local q0=GetFuelTankMaxVolume;local cc=13;local e6=b.getElementIdList()local e7=0;local function s(az,aA)if az==0 then return aV(aA)<1e-09 elseif aA==0 then return aV(az)<1e-09 else return aV(az-aA)<math.max(aV(az),aV(aA))*epsilon end end;local function bF(F,q1)local m4=10^(q1 or 0)return g(F*m4+0.5)/m4 end;local function e2(q2,q3)for N,A in pairs(q3)do if type(N)=="string"then q2[N]=A else q2[#q2+1]=q3[N]end end;return q2 end;local function e3(q4)local q5={}if not q4 then e2(q5,saveableVariablesBoolean)e2(q5,savableVariablesHandling)e2(q5,savableVariablesHud)e2(q5,savableVariablesPhysics)return q5 elseif q4=="boolean"then return saveableVariablesBoolean elseif q4=="handling"then return savableVariablesHandling elseif q4=="hud"then return savableVariablesHud elseif q4=="physics"then return savableVariablesPhysics end end;local function k(nV)if not nV then return end;if msgText~="empty"then if not string.find(msgText,nV)then msgText=msgText.."\n"..nV;msgTimer=7 end else msgText=nV end end;local function ky(q6)local function q7(q8)for N,A in pairs(q8)do dbHud_1.setStringValue(N,pj(A.get()))if q6 and dbHud_2 then dbHud_2.setStringValue(N,pj(A.get()))end end end;if dbHud_1 then q7(autoVariables)q7(e3())a.print("Saved Variables to Datacore")if q6 and dbHud_2 then k("Databank copied.  Remove copy when ready.")end end end;local function bE(q9,qa,type)if type==nil and not voices or type~=nil and not alerts or soundFolder=="archHUD"then return end;a.playSound(soundFolder.."/"..q9 ..".mp3")end;local function cb(d4,d5,m2,eY,qb)return n([[<text class="%s" x=%s y=%s style="%s">%s</text>]],eY or"",d4,d5,qb or"",m2)end;local function e4(distance,qc)qc=qc or 1;local unit="m"if distance>100000 then distance=distance/200000;unit="su"elseif distance>1000 then distance=distance/1000;unit="km"end;return bF(distance,qc)..unit end;local function e5(qd)local qe=0;local qf=0;local qg=0;if qd<60 then qd=g(qd)elseif qd<3600 then qe=g(qd/60)qd=g(qd%60)elseif qd<86400 then qf=g(qd/3600)qe=g(qd%3600/60)else qg=g(qd/86400)qf=g(qd%86400/3600)end;if qg>365 then return">1y"elseif qg>0 then return qg.."d "..qf.."h "elseif qf>0 then return qf.."h "..qe.."m "elseif qe>0 then return qe.."m "..qd.."s"elseif qd>0 then return qd.."s"else return"0s"end end;local function qh()if radar_1 then RADAR=c9(b,a,c,radar_1,radar_2,warpdrive,aV,ca,r,cb,q,cc,bE,k)end end;function pY.radarSetup()qh()end;function pY.onStart()local qi=false;local function qj()local function qk(ql)local qm=dbHud_1.hasKey;for N,A in pairs(ql)do if qm(N)then local I=dY(dbHud_1.getStringValue(N))if I~=nil then A.set(I)qi=true end end end end;pcall(require,"autoconf/custom/archhud/custom/userglobals")if dbHud_1 then if not useTheseSettings then qk(e3())coroutine.yield()qk(autoVariables)else qk(autoVariables)k("Updated user preferences used.  Will be saved when you exit seat.\nToggle off useTheseSettings to use database saved values")msgTimer=5;qi=false end;coroutine.yield()if qi then k("Loaded Saved Variables")elseif not useTheseSettings then k("Databank Found, No Saved Variables Found\nVariables will save to Databank on standing")msgTimer=5 end;if#SavedLocations>0 then customlocations=e2(customlocations,SavedLocations)end else k("No databank found. Attach one to control unit and rerun \nthe autoconfigure to save preferences and locations")end;BrakeToggleStatus=BrakeToggleDefault;userControlScheme=string.lower(userControlScheme)autoRoll=autoRollPreference;adjustedAtmoSpeedLimit=AtmoSpeedLimit;if LastStartTime+180<time then LastMaxBrakeInAtmo=0 end;LastStartTime=time;userControlScheme=string.lower(userControlScheme)if string.find("keyboard virtual joystick mouse",userControlScheme)==nil then k("Invalid User Control Scheme selected.\nChange userControlScheme in Lua Parameters to keyboard, mouse, or virtual joystick\nOr use shift and button in screen")msgTimer=7 end;if antigrav and not ExternalAGG then if AntigravTargetAltitude==nil then AntigravTargetAltitude=coreAltitude end;antigrav.setTargetAltitude(AntigravTargetAltitude)end;if pcall(require,"autoconf/custom/archhud/"..privateFile)then if#privatelocations>0 then customlocations=e2(customlocations,privatelocations)end end;VectorStatus="Proceeding to Waypoint"if MaxGameVelocity==-1 then adjMaxGameVelocity=j.getMaxSpeed()end end;local function qn()local function qo(qp,qq)if qp>qq then qq=qp end;local qr,qs=0,0;if ContainerOptimization>0 then qr=ContainerOptimization*0.05 end;if FuelTankOptimization>0 then qs=FuelTankOptimization*0.05 end;qq=qq*(1-(qr+qs))return qq end;local function qt(W,bY,j0,qu,qv,qw,qx,qp,jg,iQ)local qy=qu*qv;if qw>0 then qy=qy+qy*qw*0.2 end;qy=qo(qp,qy)local je=0;for jf=1,iQ do if bY==dY(c[j0 .."fueltank_"..jf].getWidgetData()).name then je=jf;break end end;return{W,string.sub(bY,1,12),qy,qx,qp,jg,je}end;local qz=b.getElementNameById;local qA=fuelX~=0 and fuelY~=0;local qB=_G["atmofueltank_size"]local qC=_G["spacefueltank_size"]local qD=_G["rocketfueltank_size"]local qE=4;local qF=6;local qG=0.8;for N in pairs(e6)do local type=b.getElementDisplayNameById(e6[N])if stringmatch(type,'^.*Atmospheric Engine$')then if stringmatch(tostring(b.getEngineTagsById(e6[N])),'^.*vertical.*$')and b.getElementForwardById(e6[N])[3]>0 then UpVertAtmoEngine=true end end;if stringmatch(type,'^.*Space Engine$')then SpaceEngines=true;if stringmatch(tostring(b.getEngineTagsById(e6[N])),'^.*vertical.*$')then local qH=b.getElementForwardById(e6[N])if qH[3]<0 then SpaceEngineVertUp=true else SpaceEngineVertDn=true end end end;if type=="Landing Gear"then hasGear=true end;if type=="Dynamic Core Unit"then local jL=jJ(e6[N])if jL>10000 then cc=110 elseif jL>1000 then cc=55 elseif jL>150 then cc=27 end end;e7=e7+jJ(e6[N])if qA then local pU=b.getElementItemIdById(e6[N])if pZ(pU,"FuelContainer")then local qI=p_(pU)local a_=dZ(e6[N])local jg=f()local qq=q0(pU,qI.size)local qx=qI.unitMass;local bY=qz(e6[N])local qp=a_-qx;if pZ(pU,"AtmoFuelContainer")then atmoTanks[#atmoTanks+1]=qt(e6[N],bY,"atmo",qq,qE*GetFuelTankModifier(pU),fuelTankHandlingAtmo,qx,qp,jg,qB)elseif pZ(pU,"RocketFuelContainer")then rocketTanks[#rocketTanks+1]=qt(e6[N],bY,"rocket",qq,qG*GetFuelTankModifier(pU),fuelTankHandlingRocket/2,qx,qp,jg,qD)elseif pZ(pU,"SpaceFuelContainer")then spaceTanks[#spaceTanks+1]=qt(e6[N],bY,"space",qq,qF*GetFuelTankModifier(pU),fuelTankHandlingSpace,qx,qp,jg,qC)end end end end;if not UpVertAtmoEngine then VertTakeOff,VertTakeOffEngine=false,false end end;local function qJ()if gyro~=nil then gyroIsOn=gyro.isActive()end;if not stablized then e0:deactivateGroundEngineAltitudeStabilization()end;if userControlScheme~="keyboard"then ph(true)else ph(false)end;if door and(inAtmo or not inAtmo and coreAltitude<10000)then for _,A in pairs(door)do A.toggle()end end;if switch then for _,A in pairs(switch)do A.toggle()end end;if forcefield and(inAtmo or not inAtmo==0 and coreAltitude<10000)then for _,A in pairs(forcefield)do A.toggle()end end;if antigrav then antigravOn=antigrav.isActive()if antigravOn and not ExternalAGG then antigrav.showWidget()end end;if d_()and RemoteFreeze then pW.freeze(true)else pW.freeze(false)end;if hasGear then if abvGndDet~=-1 and not antigravOn then d.control.deployLandingGears()else d.control.retractLandingGears()end end;GearExtended=d.control.isAnyLandingGearDeployed()or not stablized or abvGndDet~=-1 and abvGndDet-3<LandingGearGroundHeight;local qK=coreVelocity:len()<30;if abvGndDet~=-1 and stabilzied or(not inAtmo or not stabilzied)and qK then BrakeIsOn="Startup"else BrakeIsOn=false end;e0:setTargetGroundAltitude(LandingGearGroundHeight)WasInAtmo=inAtmo end;local function qL()local qM={}local function qN()return{id=0,name={"Space","Space","Space"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=0,satellites={},center={0,0,0},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local function qO()return{id=1000,name={"Aegis","Aegis","Aegis"},type={},biosphere={},classification={},habitability={},description={},iconPath="",hasAtmosphere=false,isSanctuary=false,isInSafeZone=true,systemId=0,positionInSystem=1000,satellites={},center={13856549.3576,7386341.6738,-258459.8925},gravity=0,radius=0,atmosphereThickness=0,atmosphereRadius=0,surfaceArea=0,surfaceAverageAltitude=0,surfaceMaxAltitude=0,surfaceMinAltitude=0,GM=0,ores={},territories=0,noAtmosphericDensityAltitude=0,spaceEngineMinAltitude=0}end;local qP={[1]=6637,[2]=3426,[4]=7580,[26]=4242,[27]=4150,[3]=21452,[6]=4498,[7]=6285,[8]=3434,[9]=5916}for qQ,qR in pairs(l)do l[qQ][0]=qN()l[qQ][0].systemId=qQ;l[qQ][1000]=qO()qM[qQ]={}for qS,planet in pairs(l[qQ])do planet.gravity=planet.gravity/9.8;planet.center=vec3(planet.center)planet.name=planet.name[1]planet.noAtmosphericDensityAltitude=planet.atmosphereThickness;planet.spaceEngineMinAltitude=qP[planet.id]or 0.5353125*planet.atmosphereThickness;planet.planetarySystemId=qQ;planet.bodyId=planet.id;qM[qQ][qS]=planet;if minAtlasX==nil or planet.center.x<minAtlasX then minAtlasX=planet.center.x end;if maxAtlasX==nil or planet.center.x>maxAtlasX then maxAtlasX=planet.center.x end;if minAtlasY==nil or planet.center.y<minAtlasY then minAtlasY=planet.center.y end;if maxAtlasY==nil or planet.center.y>maxAtlasY then maxAtlasY=planet.center.y end;if planet.center and planet.name~="Space"then planetAtlas[#planetAtlas+1]=planet end end end;PlanetaryReference=m(d,b,c,a,n,o,q,r,s)galaxyReference=PlanetaryReference(qM)sys=galaxyReference[0]Kinematic=aU(d,b,c,a,r,aV)Kep=be(d,b,c,a,n,o,q,r,s)ATLAS=bB(d,b,c,a,dbHud_1,l,bC,bD,g,q,r,bE,bF,k)planet=galaxyReference[0]:closestBody(j.getWorldPosition())end;SetupComplete=false;beginSetup=coroutine.create(function()e0:setupCustomTargetSpeedRanges(axisCommandId.longitudinal,{1000,5000,10000,20000,30000})qj()coroutine.yield()qn()coroutine.yield()AP=kx(d,b,c,l,vBooster,hover,telemeter_1,antigrav,dbHud_1,aV,g,h,d_,atan,f,o,e0,bC,e1,r,bF,bE,e2,s,e4,e5,ky,dY,k)qJ()coroutine.yield()qL()qh()if dX then HUD=dX(d,b,c,a,l,antigrav,hover,shield,warpdrive,weapon,aV,g,n,dY,h,dZ,d_,atan,f,o,e0,bD,bC,ca,e1,r,bF,cb,bE,e2,e3,e4,e5,e6,e7,k)end;if HUD then HUD.ButtonSetup()end;CONTROL=pg(d,b,c,a,l,vBooster,hover,antigrav,shield,dbHud_2,gyro,screenHud_1,d_,e0,e1,ph,ca,bF,stringmatch,q,o,bE,e3,ky,k,pi,pj)if shield then SHIELD=dI(shield,stringmatch,g,k)end;coroutine.yield()c.hideWidget()a.showScreen(true)a.showHelper(false)if screenHud_1 then screenHud_1.setCenteredText("")end;collectgarbage("collect")coroutine.yield()c.setTimer("apTick",0.0166667)c.setTimer("hudTick",hudTickRate)c.setTimer("oneSecond",1)c.setTimer("tenthSecond",1/10)j.setDockingMode(DockingMode)if shield then c.setTimer("shieldTick",0.0166667)end;if userBase then PROGRAM.ExtraOnStart()end;local function qT()if ecuThrottle[1]==0 then AP.cmdThrottle(ecuThrottle[2])else if atmosDensity>0 then adjustedAtmoSpeedLimit=ecuThrottle[2]AP.cmdThrottle(1)end end end;ECU=string.find(a.getItem(c.getItemId())['displayName'],"Emergency")or false;if ECU then if abvGndDet>-1 and velMag<1 and abvGndDet-3<LandingGearGroundHeight then c.exit()else if ECUHud then qT()else if atmosDensity==0 then BrakeIsOn="ECU Braking"elseif abvGndDet==-1 then CONTROL.landingGear()end;if antigrav~=nil then antigrav.activate()antigrav.show()end end end elseif ECUHud and ecuThrottle[3]+3>f()then qT()end;ships=j.getDockedConstructs()passengers=j.getPlayersOnBoard()local qU;qU=#passengers>1 and"Passengers: "..#passengers-1 .." "or""qU=qU..(#ships>0 and"Ships: "..#ships or"")if qU~=""then k("NOTICE: Docked "..qU)end;bE("start","SU")end)coroutine.resume(beginSetup)end;function pY.onUpdate()if SetupComplete then d:update()if inAtmo and AtmoSpeedAssist and throttleMode then if throttleMode and WasInCruise then AP.cmdThrottle(0)WasInCruise=false elseif not throttleMode and not WasInCruise then PlayerThrottle=0;WasInCruise=true end end;if ThrottleValue then e0:setThrottleCommand(axisCommandId.longitudinal,ThrottleValue)ThrottleValue=nil end;if not Animating and content~=LastContent then a.setScreen(content)end;LastContent=content;if ECU and not ECUHud and atmosDensity>0 and abvGndDet==-1 then CONTROL.landingGear()end;if ECU and abvGndDet>-1 and velMag<1 and abvGndDet-3<LandingGearGroundHeight then c.exit()end;if userBase then PROGRAM.ExtraOnUpdate()end else local dA=coroutine.status(beginSetup)if dA=="suspended"then local O,dB=coroutine.resume(beginSetup)if dB then a.print("ERROR STARTUP: "..dB)end elseif dA=="dead"then SetupComplete=true end end end;function pY.onFlush()if SetupComplete then AP.onFlush()if userBase then PROGRAM.ExtraOnFlush()end end end;function pY.onStop()_autoconf.hideCategoryPanels()if antigrav~=nil and not ExternalAGG then antigrav.hideWidget()end;if warpdrive~=nil then warpdrive.hideWidget()end;b.hideWidget()d.control.switchOffHeadlights()if door and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,A in pairs(door)do A.toggle()end end;if switch then for _,A in pairs(switch)do A.toggle()end end;if forcefield and(atmosDensity>0 or atmosDensity==0 and coreAltitude<10000)then for _,A in pairs(forcefield)do A.toggle()end end;showHud=oldShowHud;local qV=0;if ECU then qV=f()end;if e0:getAxisCommandType(0)==0 then ecuThrottle={0,PlayerThrottle,qV}else ecuThrottle={1,e0:getTargetSpeed(axisCommandId.longitudinal),qV}end;ky()if button then button.activate()end;if SetWaypointOnExit then AP.showWayPoint(planet,worldPos)end;if HUD then a.print(HUD.FuelUsed("atmofueltank")..", "..HUD.FuelUsed("spacefueltank")..", "..HUD.FuelUsed("rocketfueltank"))end;if userBase then PROGRAM.ExtraOnStop()end;bE("stop","SU")end;function pY.controlStart(ps)if SetupComplete then CONTROL.startControl(ps)end end;function pY.controlStop(ps)if SetupComplete then CONTROL.stopControl(ps)end end;function pY.controlLoop(ps)if SetupComplete then CONTROL.loopControl(ps)end end;function pY.controlInput(m2)if SetupComplete then CONTROL.inputTextControl(m2)end end;function pY.radarEnter(W)if RADAR then RADAR.onEnter(W)end end;function pY.radarLeave(W)if RADAR then RADAR.onLeave(W)end end;function pY.onTick(qW)if qW=="tenthSecond"then if AP then AP.TenthTick()end;if HUD then HUD.TenthTick()end elseif qW=="oneSecond"then if HUD then HUD.OneSecondTick()end elseif qW=="msgTick"then if HUD then HUD.MsgTick()end elseif qW=="animateTick"then if HUD then HUD.AnimateTick()end elseif qW=="hudTick"then if HUD then HUD.hudtick()end elseif qW=="apTick"then if AP then AP.APTick()end elseif qW=="shieldTick"then SHIELD.shieldTick()elseif qW=="tagTick"then CONTROL.tagTick()elseif qW=="contact"then RADAR.ContactTick()end end;if userBase then for N,A in pairs(userBase)do pY[N]=A end end;return pY end;function script.onStart()PROGRAM.onStart()end;function script.onOnStop()PROGRAM.onStop()end;function script.onTick(qW)PROGRAM.onTick(qW)end;function script.onOnFlush()PROGRAM.onFlush()end;function script.onOnUpdate()PROGRAM.onUpdate()end;function script.onActionStart(ps)PROGRAM.controlStart(ps)end;function script.onActionStop(ps)PROGRAM.controlStop(ps)end;function script.onActionLoop(ps)PROGRAM.controlLoop(ps)end;function script.onInputText(m2)PROGRAM.controlInput(m2)end;function script.onEnter(W)PROGRAM.radarEnter(W)end;function script.onLeave(W)PROGRAM.radarLeave(W)end;e(core,unit,system.getArkTime,math.floor,unit.getAtmosphereDensity)PROGRAM=pV(d,core,unit,l,vBooster,hover,telemeter_1,antigrav,dbHud_1,dbHud_2,radar_1,radar_2,shield,gyro,warpdrive,weapon,screenHud_1,transponder_1)script.onStart()
         end,__wrap_lua__traceback) if not a then __wrap_lua__error(b) if not script then script={} end end 
    onStop:
      lua:       if not __wrap_lua__stopped and script.onOnStop then local a,b=xpcall(script.onOnStop,__wrap_lua__traceback,unit) if not a then __wrap_lua__error(b) end end
    tick(timerId):
      lua:       if not __wrap_lua__stopped and script.onTick then local a,b=xpcall(script.onTick,__wrap_lua__traceback,timerId,unit) if not a then __wrap_lua__error(b) end end
  system:
    actionStart(action):
      lua:       if not __wrap_lua__stopped and script.onActionStart then local a,b=xpcall(script.onActionStart,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionStop(action):
      lua:       if not __wrap_lua__stopped and script.onActionStop then local a,b=xpcall(script.onActionStop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    actionLoop(action):
      lua:       if not __wrap_lua__stopped and script.onActionLoop then local a,b=xpcall(script.onActionLoop,__wrap_lua__traceback,action,system) if not a then __wrap_lua__error(b) end end
    onUpdate:
      lua:       if not __wrap_lua__stopped and script.onOnUpdate then local a,b=xpcall(script.onOnUpdate,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    onFlush:
      lua:       if not __wrap_lua__stopped and script.onOnFlush then local a,b=xpcall(script.onOnFlush,__wrap_lua__traceback,system) if not a then __wrap_lua__error(b) end end
    inputText(text):
      lua:       if not __wrap_lua__stopped and script.onInputText then local a,b=xpcall(script.onInputText,__wrap_lua__traceback,text,system) if not a then __wrap_lua__error(b) end end
  radar_1:
    enter(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_1
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
  radar_2:
    enter(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onEnter then local a,b=xpcall(script.onEnter,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
    leave(id):
      lua: |
        local radar = radar_2
              if not __wrap_lua__stopped and script.onLeave then local a,b=xpcall(script.onLeave,__wrap_lua__traceback,id,radar) if not a then __wrap_lua__error(b) end end
